import * as React from 'react';
import { EmptyObject, NonUndefined, LiteralToPrimitive, DeepPartial, DeepMap, IsFlatObject, LiteralUnion } from './utils';
declare const $NestedValue: unique symbol;
export declare type FieldValues = Record<string, any>;
export declare type InternalFieldName<TFieldValues extends FieldValues> = (keyof TFieldValues & string) | string;
export declare type FieldName<TFieldValues extends FieldValues> = IsFlatObject<TFieldValues> extends true ? Extract<keyof TFieldValues, string> : string;
export declare type FieldValue<TFieldValues extends FieldValues> = TFieldValues[InternalFieldName<TFieldValues>];
export declare type NestedValue<TValue extends any[] | Record<string, unknown> = any[] | Record<string, unknown>> = {
    [$NestedValue]: never;
} & TValue;
export declare type UnpackNestedValue<T> = NonUndefined<T> extends NestedValue<infer U> ? U : NonUndefined<T> extends Date | FileList ? T : NonUndefined<T> extends Record<string, unknown> ? {
    [K in keyof T]: UnpackNestedValue<T[K]>;
} : T;
export declare type DefaultValuesAtRender<TFieldValues> = UnpackNestedValue<DeepPartial<Record<InternalFieldName<TFieldValues>, FieldValue<TFieldValues>>>>;
export declare type FieldElement<TFieldValues extends FieldValues = FieldValues> = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement | CustomElement<TFieldValues>;
export declare type Ref = FieldElement;
export declare type ValidationMode = {
    onBlur: 'onBlur';
    onChange: 'onChange';
    onSubmit: 'onSubmit';
    onTouched: 'onTouched';
    all: 'all';
};
export declare type Mode = keyof ValidationMode;
export declare type SubmitHandler<TFieldValues extends FieldValues> = (data: UnpackNestedValue<TFieldValues>, event?: React.BaseSyntheticEvent) => void | Promise<void>;
export declare type SubmitErrorHandler<TFieldValues extends FieldValues> = (errors: FieldErrors<TFieldValues>, event?: React.BaseSyntheticEvent) => void | Promise<void>;
export declare type ResolverSuccess<TFieldValues extends FieldValues = FieldValues> = {
    values: UnpackNestedValue<TFieldValues>;
    errors: EmptyObject;
};
export declare type ResolverError<TFieldValues extends FieldValues = FieldValues> = {
    values: EmptyObject;
    errors: FieldErrors<TFieldValues>;
};
export declare type ResolverResult<TFieldValues extends FieldValues = FieldValues> = ResolverSuccess<TFieldValues> | ResolverError<TFieldValues>;
export declare type Resolver<TFieldValues extends FieldValues = FieldValues, TContext extends object = object> = (values: TFieldValues, context?: TContext, validateAllFieldCriteria?: boolean) => Promise<ResolverResult<TFieldValues>> | ResolverResult<TFieldValues>;
export declare type UseFormOptions<TFieldValues extends FieldValues = FieldValues, TContext extends object = object> = Partial<{
    mode: Mode;
    reValidateMode: Exclude<Mode, 'onTouched' | 'all'>;
    defaultValues: UnpackNestedValue<DeepPartial<TFieldValues>>;
    resolver: Resolver<TFieldValues, TContext>;
    context: TContext;
    shouldFocusError: boolean;
    shouldUnregister: boolean;
    criteriaMode: 'firstError' | 'all';
}>;
export declare type Message = string;
export declare type ValidationValue = boolean | number | string | RegExp;
export declare type ValidationRule<TValidationValue extends ValidationValue = ValidationValue> = TValidationValue | ValidationValueMessage<TValidationValue>;
export declare type ValidationValueMessage<TValidationValue extends ValidationValue = ValidationValue> = {
    value: TValidationValue;
    message: Message;
};
export declare type ValidateResult = Message | Message[] | boolean | undefined;
export declare type Validate = (data: any) => ValidateResult | Promise<ValidateResult>;
export declare type ValidationRules = Partial<{
    required: Message | ValidationRule<boolean>;
    min: ValidationRule<number | string>;
    max: ValidationRule<number | string>;
    maxLength: ValidationRule<number | string>;
    minLength: ValidationRule<number | string>;
    pattern: ValidationRule<RegExp>;
    validate: Validate | Record<string, Validate>;
}>;
export declare type MultipleFieldErrors = {
    [K in keyof ValidationRules]?: ValidateResult;
} & {
    [key: string]: ValidateResult;
};
export declare type FieldError = {
    type: LiteralUnion<keyof ValidationRules, string>;
    ref?: Ref;
    types?: MultipleFieldErrors;
    message?: Message;
};
export declare type ErrorOption = {
    types: MultipleFieldErrors;
} | {
    message?: Message;
    type: LiteralUnion<keyof ValidationRules, string>;
};
export declare type Field = {
    ref: Ref;
    mutationWatcher?: MutationObserver;
    options?: RadioOrCheckboxOption[];
} & ValidationRules;
export declare type FieldRefs<TFieldValues extends FieldValues> = Partial<Record<InternalFieldName<TFieldValues>, Field>>;
export declare type FieldErrors<TFieldValues extends FieldValues = FieldValues> = DeepMap<TFieldValues, FieldError>;
export declare type FlatFieldErrors<TFieldValues extends FieldValues> = Partial<Record<InternalFieldName<TFieldValues>, FieldError>>;
export declare type Touched<TFieldValues extends FieldValues> = DeepMap<TFieldValues, true>;
export declare type Dirtied<TFieldValues extends FieldValues> = DeepMap<TFieldValues, true>;
export declare type SetValueConfig = Partial<{
    shouldValidate: boolean;
    shouldDirty: boolean;
}>;
export declare type FormStateProxy<TFieldValues extends FieldValues = FieldValues> = {
    isDirty: boolean;
    dirtyFields: Dirtied<TFieldValues>;
    isSubmitted: boolean;
    submitCount: number;
    touched: Touched<TFieldValues>;
    isSubmitting: boolean;
    isValid: boolean;
};
export declare type ReadFormState = {
    [K in keyof FormStateProxy]: boolean;
};
export declare type RadioOrCheckboxOption = {
    ref: HTMLInputElement;
    mutationWatcher?: MutationObserver;
};
export declare type CustomElement<TFieldValues extends FieldValues> = {
    name: FieldName<TFieldValues>;
    type?: string;
    value?: any;
    checked?: boolean;
    options?: HTMLOptionsCollection;
    files?: FileList | null;
    focus?: () => void;
};
export declare type HandleChange = (event: Event) => Promise<void | boolean>;
export declare type FieldValuesFromControl<TControl extends Control> = TControl extends Control<infer TFieldValues> ? TFieldValues : never;
export declare type FieldArrayName = string;
export declare type UseFieldArrayOptions<TKeyName extends string = 'id', TControl extends Control = Control> = {
    name: FieldArrayName;
    keyName?: TKeyName;
    control?: TControl;
};
export declare type Control<TFieldValues extends FieldValues = FieldValues> = Pick<UseFormMethods<TFieldValues>, 'register' | 'unregister' | 'setValue' | 'getValues' | 'trigger' | 'formState'> & {
    reRender: () => void;
    removeFieldEventListener: (field: Field, forceDelete?: boolean) => void;
    mode: {
        readonly isOnBlur: boolean;
        readonly isOnSubmit: boolean;
        readonly isOnChange: boolean;
        readonly isOnAll: boolean;
        readonly isOnTouch: boolean;
    };
    reValidateMode: {
        readonly isReValidateOnBlur: boolean;
        readonly isReValidateOnChange: boolean;
    };
    fieldArrayDefaultValues: React.MutableRefObject<Record<FieldArrayName, any[]>>;
    dirtyFieldsRef: React.MutableRefObject<Dirtied<TFieldValues>>;
    validateResolver: ((fieldsValues: any) => void) | undefined;
    touchedFieldsRef: React.MutableRefObject<Touched<TFieldValues>>;
    watchFieldsRef: React.MutableRefObject<Set<InternalFieldName<TFieldValues>>>;
    isWatchAllRef: React.MutableRefObject<boolean>;
    validFieldsRef: React.MutableRefObject<Set<InternalFieldName<TFieldValues>>>;
    fieldsWithValidationRef: React.MutableRefObject<Set<InternalFieldName<TFieldValues>>>;
    errorsRef: React.MutableRefObject<FieldErrors<TFieldValues>>;
    fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>;
    resetFieldArrayFunctionRef: React.MutableRefObject<Record<string, () => void>>;
    unmountFieldsStateRef: Record<InternalFieldName<FieldValues>, any>;
    fieldArrayNamesRef: React.MutableRefObject<Set<InternalFieldName<FieldValues>>>;
    isDirtyRef: React.MutableRefObject<boolean>;
    isSubmittedRef: React.MutableRefObject<boolean>;
    readFormStateRef: React.MutableRefObject<{
        [k in keyof FormStateProxy<TFieldValues>]: boolean;
    }>;
    defaultValuesRef: React.MutableRefObject<FieldValue<UnpackNestedValue<TFieldValues>> | UnpackNestedValue<DeepPartial<TFieldValues>>>;
    watchFieldsHookRef: React.MutableRefObject<Record<string, Set<InternalFieldName<TFieldValues>>>>;
    watchFieldsHookRenderRef: React.MutableRefObject<Record<string, Function>>;
    watchInternal: (fieldNames?: string | string[], defaultValue?: unknown, watchId?: string) => unknown;
    renderWatchedInputs: (name: string, found?: boolean) => void;
};
export declare type ArrayField<TFieldArrayValues extends FieldValues = FieldValues, TKeyName extends string = 'id'> = TFieldArrayValues & Record<TKeyName, string>;
export declare type OmitResetState = Partial<{
    errors: boolean;
} & ReadFormState>;
export declare type UseWatchOptions = {
    defaultValue?: unknown;
    name?: string | string[];
    control?: Control;
};
export declare type UseFormMethods<TFieldValues extends FieldValues = FieldValues> = {
    register<TFieldElement extends FieldElement<TFieldValues>>(rules?: ValidationRules): (ref: (TFieldElement & Ref) | null) => void;
    register(name: FieldName<TFieldValues>, rules?: ValidationRules): void;
    register<TFieldElement extends FieldElement<TFieldValues>>(ref: (TFieldElement & Ref) | null, rules?: ValidationRules): void;
    unregister(name: FieldName<TFieldValues> | FieldName<TFieldValues>[]): void;
    watch(): UnpackNestedValue<TFieldValues>;
    watch<TFieldName extends string, TFieldValue>(name: TFieldName, defaultValue?: TFieldName extends keyof TFieldValues ? UnpackNestedValue<TFieldValues[TFieldName]> : UnpackNestedValue<LiteralToPrimitive<TFieldValue>>): TFieldName extends keyof TFieldValues ? UnpackNestedValue<TFieldValues[TFieldName]> : UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;
    watch<TFieldName extends keyof TFieldValues>(names: TFieldName[], defaultValues?: UnpackNestedValue<DeepPartial<Pick<TFieldValues, TFieldName>>>): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;
    watch(names: string[], defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>): UnpackNestedValue<DeepPartial<TFieldValues>>;
    setError(name: FieldName<TFieldValues>, error: ErrorOption): void;
    clearErrors(name?: FieldName<TFieldValues> | FieldName<TFieldValues>[]): void;
    setValue<TFieldName extends string, TFieldValue extends TFieldValues[TFieldName]>(name: TFieldName, value?: NonUndefined<TFieldValue> extends NestedValue<infer U> ? U : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>, options?: SetValueConfig): void;
    trigger(name?: FieldName<TFieldValues> | FieldName<TFieldValues>[]): Promise<boolean>;
    errors: FieldErrors<TFieldValues>;
    formState: FormStateProxy<TFieldValues>;
    reset: (values?: UnpackNestedValue<DeepPartial<TFieldValues>>, omitResetState?: OmitResetState) => void;
    getValues(): UnpackNestedValue<TFieldValues>;
    getValues<TFieldName extends string, TFieldValue extends unknown>(name: TFieldName): TFieldName extends keyof TFieldValues ? UnpackNestedValue<TFieldValues>[TFieldName] : TFieldValue;
    getValues<TFieldName extends keyof TFieldValues>(names: TFieldName[]): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;
    handleSubmit: <TSubmitFieldValues extends FieldValues = TFieldValues>(onValid: SubmitHandler<TSubmitFieldValues>, onInvalid?: SubmitErrorHandler<TFieldValues>) => (e?: React.BaseSyntheticEvent) => Promise<void>;
    control: Control<TFieldValues>;
};
export {};
