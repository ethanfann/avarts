{"version":3,"file":"togeojson.umd.js","sources":["../lib/shared.js","../lib/gpx.js","../lib/kml.js"],"sourcesContent":["// cast array x into numbers\n// get the content of a text node, if any\nexport function nodeVal(x) {\n  if (x && x.normalize) {\n    x.normalize();\n  }\n  return (x && x.textContent) || \"\";\n}\n","import { nodeVal } from \"./shared\";\n\nconst attributeNames = [\n  [\"speed\", \"speeds\"],\n  [\"course\", \"courses\"],\n  [\"hAcc\", \"hAccs\"],\n  [\"vAcc\", \"vAccs\"],\n  [\"heartRate\", \"heartRates\"],\n];\n\nfunction getLineStyle(extensions) {\n  const style = {};\n  if (extensions) {\n    const lineStyle = get1(extensions, \"line\");\n    if (lineStyle) {\n      const color = nodeVal(get1(lineStyle, \"color\")),\n        opacity = parseFloat(nodeVal(get1(lineStyle, \"opacity\"))),\n        width = parseFloat(nodeVal(get1(lineStyle, \"width\")));\n      if (color) style.stroke = color;\n      if (!isNaN(opacity)) style[\"stroke-opacity\"] = opacity;\n      // GPX width is in mm, convert to px with 96 px per inch\n      if (!isNaN(width)) style[\"stroke-width\"] = (width * 96) / 25.4;\n    }\n  }\n  return style;\n}\n\n// get the contents of multiple text nodes, if present\nfunction getMulti(x, ys) {\n  const o = {};\n  let n;\n  let k;\n  for (k = 0; k < ys.length; k++) {\n    n = get1(x, ys[k]);\n    if (n) o[ys[k]] = nodeVal(n);\n  }\n  return o;\n}\nfunction getProperties(node) {\n  const prop = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n  // Parse additional data from our Garmin extension(s)\n  const extensions = node.getElementsByTagNameNS(\n    \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n    \"*\"\n  );\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    // Ignore nested extensions, like those on routepoints or trackpoints\n    if (extension.parentNode.parentNode === node) {\n      prop[extension.tagName.replace(\":\", \"_\")] = nodeVal(extension);\n    }\n  }\n  const links = node.getElementsByTagName(\"link\");\n  if (links.length) prop.links = [];\n  for (let i = 0; i < links.length; i++) {\n    prop.links.push(\n      Object.assign(\n        { href: links[i].getAttribute(\"href\") },\n        getMulti(links[i], [\"text\", \"type\"])\n      )\n    );\n  }\n  return prop;\n}\n\n// one Y child of X, if any, otherwise null\nfunction get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}\n\nfunction coordPair(x) {\n  const ll = [\n    parseFloat(x.getAttribute(\"lon\")),\n    parseFloat(x.getAttribute(\"lat\")),\n  ];\n  const ele = get1(x, \"ele\");\n  // handle namespaced attribute in browser\n  const heartRate = get1(x, \"gpxtpx:hr\") || get1(x, \"hr\");\n  const time = get1(x, \"time\");\n  let e;\n  if (ele) {\n    e = parseFloat(nodeVal(ele));\n    if (!isNaN(e)) {\n      ll.push(e);\n    }\n  }\n  const result = {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n  };\n\n  const extensions = get1(x, \"extensions\");\n  if (extensions !== null) {\n    attributeNames\n      .map((r) => r[0])\n      .filter((n) => n !== \"heartrate\")\n      .forEach((name) => {\n        const raw = get1(extensions, name);\n        if (raw !== null) {\n          const v = parseFloat(nodeVal(raw));\n          if (!isNaN(v)) {\n            result[name] = v;\n          }\n        }\n      });\n  }\n  return result;\n}\nfunction getRoute(node) {\n  const line = getPoints(node, \"rtept\");\n  if (!line.line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      getProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\nfunction getPoints(node, pointname) {\n  const pts = node.getElementsByTagName(pointname);\n  const line = [];\n  const times = [];\n  const l = pts.length;\n  const extendedValues = {};\n  if (l < 2) return {}; // Invalid line in GeoJSON\n  for (let i = 0; i < l; i++) {\n    const c = coordPair(pts[i]);\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    attributeNames\n      .map((r) => r[0])\n      .forEach((name) => {\n        if (c[name] || extendedValues[name]) {\n          if (!extendedValues[name]) {\n            extendedValues[name] = Array(i).fill(null);\n          }\n          extendedValues[name].push(c[name] || null);\n        }\n      });\n  }\n  const result = {\n    line: line,\n    times: times,\n  };\n  attributeNames.forEach((n) => {\n    if (extendedValues[n[0]]) {\n      result[n[1]] = extendedValues[n[0]] || [];\n    }\n  });\n  return result;\n}\nfunction getTrack(node) {\n  const segments = node.getElementsByTagName(\"trkseg\");\n  const track = [];\n  const times = [];\n  const extendedValues = {};\n  let line;\n  for (let i = 0; i < segments.length; i++) {\n    line = getPoints(segments[i], \"trkpt\");\n    if (line) {\n      if (line.line) track.push(line.line);\n      if (line.times && line.times.length) times.push(line.times);\n\n      attributeNames\n        .map((r) => r[1])\n        .forEach((name) => {\n          if (\n            (extendedValues[name] && extendedValues[name].length) ||\n            (line[name] && line[name].length)\n          ) {\n            if (!extendedValues[name]) {\n              extendedValues[name] = [];\n            }\n            if (!extendedValues[name].length) {\n              for (let s = 0; s < i; s++) {\n                extendedValues[name].push(Array(track[s].length).fill(null));\n              }\n            }\n            if (line[name] && line[name].length) {\n              extendedValues[name].push(line[name]);\n            } else {\n              extendedValues[name].push(\n                Array(line.line.length || 0).fill(null)\n              );\n            }\n          }\n        });\n    }\n  }\n  if (track.length === 0) return;\n  const properties = Object.assign(\n    getProperties(node),\n    getLineStyle(get1(node, \"extensions\"))\n  );\n  if (times.length)\n    properties.coordTimes = track.length === 1 ? times[0] : times;\n  attributeNames.forEach((n) => {\n    if (extendedValues[n[1]] && extendedValues[n[1]].length) {\n      properties[n[1]] =\n        track.length === 1 ? extendedValues[n[1]][0] : extendedValues[n[1]];\n    }\n  });\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: {\n      type: track.length === 1 ? \"LineString\" : \"MultiLineString\",\n      coordinates: track.length === 1 ? track[0] : track,\n    },\n  };\n}\n\nfunction getPoint(node) {\n  return {\n    type: \"Feature\",\n    properties: Object.assign(getProperties(node), getMulti(node, [\"sym\"])),\n    geometry: {\n      type: \"Point\",\n      coordinates: coordPair(node).coordinates,\n    },\n  };\n}\n\nexport function* gpxGen(doc) {\n  const tracks = doc.getElementsByTagName(\"trk\");\n  const routes = doc.getElementsByTagName(\"rte\");\n  const waypoints = doc.getElementsByTagName(\"wpt\");\n\n  for (let i = 0; i < tracks.length; i++) {\n    const feature = getTrack(tracks[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < routes.length; i++) {\n    const feature = getRoute(routes[i]);\n    if (feature) yield feature;\n  }\n  for (let i = 0; i < waypoints.length; i++) {\n    yield getPoint(waypoints[i]);\n  }\n}\n\nexport function gpx(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(doc)),\n  };\n}\n","import { nodeVal } from \"./shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n// generate a short, numeric hash of a string\nfunction okhash(x) {\n  if (!x || !x.length) return 0;\n  let h = 0;\n  for (let i = 0; i < x.length; i++) {\n    h = ((h << 5) - h + x.charCodeAt(i)) | 0;\n  }\n  return h;\n}\n\n// one Y child of X, if any, otherwise null\nfunction get1(x, y) {\n  const n = x.getElementsByTagName(y);\n  return n.length ? n[0] : null;\n}\n\n// get one coordinate from a coordinate array, if any\nfunction coord1(v) {\n  return v.replace(removeSpace, \"\").split(\",\").map(parseFloat);\n}\n\n// get all coordinates from a coordinate array as [[],[]]\nfunction coord(v) {\n  return v.replace(trimSpace, \"\").split(splitSpace).map(coord1);\n}\n\nfunction xml2str(node) {\n  if (node.xml !== undefined) return node.xml;\n  if (node.tagName) {\n    let output = node.tagName;\n    for (let i = 0; i < node.attributes.length; i++) {\n      output += node.attributes[i].name + node.attributes[i].value;\n    }\n    for (let i = 0; i < node.childNodes.length; i++) {\n      output += xml2str(node.childNodes[i]);\n    }\n    return output;\n  }\n  if (node.nodeName === \"#text\") {\n    return (node.nodeValue || node.value || \"\").trim();\n  }\n  if (node.nodeName === \"#cdata-section\") {\n    return node.nodeValue;\n  }\n  return \"\";\n}\n\nconst geotypes = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n\nfunction kmlColor(properties, elem, prefix) {\n  let v = nodeVal(get1(elem, \"color\")) || \"\";\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v.substr(0, 1) === \"#\") {\n    v = v.substr(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substr(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substr(6, 2) + v.substr(4, 2) + v.substr(2, 2);\n  }\n}\n\nfunction numericProperty(properties, elem, source, target) {\n  const val = parseFloat(nodeVal(get1(elem, source)));\n  if (!isNaN(val)) properties[target] = val;\n}\n\nfunction gxCoords(root) {\n  let elems = root.getElementsByTagName(\"coord\");\n  const coords = [];\n  const times = [];\n  if (elems.length === 0) elems = root.getElementsByTagName(\"gx:coord\");\n  for (let i = 0; i < elems.length; i++) {\n    coords.push(nodeVal(elems[i]).split(\" \").map(parseFloat));\n  }\n  const timeElems = root.getElementsByTagName(\"when\");\n  for (let j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n  return {\n    coords: coords,\n    times: times,\n  };\n}\n\nfunction getGeometry(root) {\n  let geomNode;\n  let geomNodes;\n  let i;\n  let j;\n  let k;\n  const geoms = [];\n  const coordTimes = [];\n  if (get1(root, \"MultiGeometry\")) {\n    return getGeometry(get1(root, \"MultiGeometry\"));\n  }\n  if (get1(root, \"MultiTrack\")) {\n    return getGeometry(get1(root, \"MultiTrack\"));\n  }\n  if (get1(root, \"gx:MultiTrack\")) {\n    return getGeometry(get1(root, \"gx:MultiTrack\"));\n  }\n  for (i = 0; i < geotypes.length; i++) {\n    geomNodes = root.getElementsByTagName(geotypes[i]);\n    if (geomNodes) {\n      for (j = 0; j < geomNodes.length; j++) {\n        geomNode = geomNodes[j];\n        if (geotypes[i] === \"Point\") {\n          geoms.push({\n            type: \"Point\",\n            coordinates: coord1(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"LineString\") {\n          geoms.push({\n            type: \"LineString\",\n            coordinates: coord(nodeVal(get1(geomNode, \"coordinates\"))),\n          });\n        } else if (geotypes[i] === \"Polygon\") {\n          const rings = geomNode.getElementsByTagName(\"LinearRing\"),\n            coords = [];\n          for (k = 0; k < rings.length; k++) {\n            coords.push(coord(nodeVal(get1(rings[k], \"coordinates\"))));\n          }\n          geoms.push({\n            type: \"Polygon\",\n            coordinates: coords,\n          });\n        } else if (geotypes[i] === \"Track\" || geotypes[i] === \"gx:Track\") {\n          const track = gxCoords(geomNode);\n          geoms.push({\n            type: \"LineString\",\n            coordinates: track.coords,\n          });\n          if (track.times.length) coordTimes.push(track.times);\n        }\n      }\n    }\n  }\n  return {\n    geoms: geoms,\n    coordTimes: coordTimes,\n  };\n}\n\nfunction getPlacemark(root, styleIndex, styleMapIndex, styleByHash) {\n  const geomsAndTimes = getGeometry(root);\n  let i;\n  const properties = {};\n  const name = nodeVal(get1(root, \"name\"));\n  const address = nodeVal(get1(root, \"address\"));\n  let styleUrl = nodeVal(get1(root, \"styleUrl\"));\n  const description = nodeVal(get1(root, \"description\"));\n  const timeSpan = get1(root, \"TimeSpan\");\n  const timeStamp = get1(root, \"TimeStamp\");\n  const extendedData = get1(root, \"ExtendedData\");\n  let iconStyle = get1(root, \"IconStyle\");\n  let labelStyle = get1(root, \"LabelStyle\");\n  let lineStyle = get1(root, \"LineStyle\");\n  let polyStyle = get1(root, \"PolyStyle\");\n  const visibility = get1(root, \"visibility\");\n\n  if (name) properties.name = name;\n  if (address) properties.address = address;\n  if (styleUrl) {\n    if (styleUrl[0] !== \"#\") {\n      styleUrl = \"#\" + styleUrl;\n    }\n\n    properties.styleUrl = styleUrl;\n    if (styleIndex[styleUrl]) {\n      properties.styleHash = styleIndex[styleUrl];\n    }\n    if (styleMapIndex[styleUrl]) {\n      properties.styleMapHash = styleMapIndex[styleUrl];\n      properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n    }\n    // Try to populate the lineStyle or polyStyle since we got the style hash\n    const style = styleByHash[properties.styleHash];\n    if (style) {\n      if (!iconStyle) iconStyle = get1(style, \"IconStyle\");\n      if (!labelStyle) labelStyle = get1(style, \"LabelStyle\");\n      if (!lineStyle) lineStyle = get1(style, \"LineStyle\");\n      if (!polyStyle) polyStyle = get1(style, \"PolyStyle\");\n    }\n  }\n  if (description) properties.description = description;\n  if (timeSpan) {\n    const begin = nodeVal(get1(timeSpan, \"begin\"));\n    const end = nodeVal(get1(timeSpan, \"end\"));\n    properties.timespan = { begin: begin, end: end };\n  }\n  if (timeStamp) {\n    properties.timestamp = nodeVal(get1(timeStamp, \"when\"));\n  }\n  if (iconStyle) {\n    kmlColor(properties, iconStyle, \"icon\");\n    numericProperty(properties, iconStyle, \"scale\", \"icon-scale\");\n    numericProperty(properties, iconStyle, \"heading\", \"icon-heading\");\n\n    const hotspot = get1(iconStyle, \"hotSpot\");\n    if (hotspot) {\n      const left = parseFloat(hotspot.getAttribute(\"x\"));\n      const top = parseFloat(hotspot.getAttribute(\"y\"));\n      if (!isNaN(left) && !isNaN(top)) properties[\"icon-offset\"] = [left, top];\n    }\n    const icon = get1(iconStyle, \"Icon\");\n    if (icon) {\n      const href = nodeVal(get1(icon, \"href\"));\n      if (href) properties.icon = href;\n    }\n  }\n  if (labelStyle) {\n    kmlColor(properties, labelStyle, \"label\");\n    numericProperty(properties, labelStyle, \"scale\", \"label-scale\");\n  }\n  if (lineStyle) {\n    kmlColor(properties, lineStyle, \"stroke\");\n    numericProperty(properties, lineStyle, \"width\", \"stroke-width\");\n  }\n  if (polyStyle) {\n    kmlColor(properties, polyStyle, \"fill\");\n    const fill = nodeVal(get1(polyStyle, \"fill\"));\n    const outline = nodeVal(get1(polyStyle, \"outline\"));\n    if (fill)\n      properties[\"fill-opacity\"] =\n        fill === \"1\" ? properties[\"fill-opacity\"] || 1 : 0;\n    if (outline)\n      properties[\"stroke-opacity\"] =\n        outline === \"1\" ? properties[\"stroke-opacity\"] || 1 : 0;\n  }\n  if (extendedData) {\n    const datas = extendedData.getElementsByTagName(\"Data\"),\n      simpleDatas = extendedData.getElementsByTagName(\"SimpleData\");\n\n    for (i = 0; i < datas.length; i++) {\n      properties[datas[i].getAttribute(\"name\")] = nodeVal(\n        get1(datas[i], \"value\")\n      );\n    }\n    for (i = 0; i < simpleDatas.length; i++) {\n      properties[simpleDatas[i].getAttribute(\"name\")] = nodeVal(simpleDatas[i]);\n    }\n  }\n  if (visibility) {\n    properties.visibility = nodeVal(visibility);\n  }\n  if (geomsAndTimes.coordTimes.length) {\n    properties.coordTimes =\n      geomsAndTimes.coordTimes.length === 1\n        ? geomsAndTimes.coordTimes[0]\n        : geomsAndTimes.coordTimes;\n  }\n  const feature = {\n    type: \"Feature\",\n    geometry:\n      geomsAndTimes.geoms.length === 0\n        ? null\n        : geomsAndTimes.geoms.length === 1\n        ? geomsAndTimes.geoms[0]\n        : {\n            type: \"GeometryCollection\",\n            geometries: geomsAndTimes.geoms,\n          },\n    properties: properties,\n  };\n  if (root.getAttribute(\"id\")) feature.id = root.getAttribute(\"id\");\n  return feature;\n}\n\nexport function* kmlGen(doc) {\n  // styleindex keeps track of hashed styles in order to match feature\n  const styleIndex = {};\n  const styleByHash = {};\n  // stylemapindex keeps track of style maps to expose in properties\n  const styleMapIndex = {};\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = doc.getElementsByTagName(\"Placemark\");\n  const styles = doc.getElementsByTagName(\"Style\");\n  const styleMaps = doc.getElementsByTagName(\"StyleMap\");\n\n  for (let k = 0; k < styles.length; k++) {\n    const hash = okhash(xml2str(styles[k])).toString(16);\n    styleIndex[\"#\" + styles[k].getAttribute(\"id\")] = hash;\n    styleByHash[hash] = styles[k];\n  }\n  for (let l = 0; l < styleMaps.length; l++) {\n    styleIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = okhash(\n      xml2str(styleMaps[l])\n    ).toString(16);\n    const pairs = styleMaps[l].getElementsByTagName(\"Pair\");\n    const pairsMap = {};\n    for (let m = 0; m < pairs.length; m++) {\n      pairsMap[nodeVal(get1(pairs[m], \"key\"))] = nodeVal(\n        get1(pairs[m], \"styleUrl\")\n      );\n    }\n    styleMapIndex[\"#\" + styleMaps[l].getAttribute(\"id\")] = pairsMap;\n  }\n  for (let j = 0; j < placemarks.length; j++) {\n    const feature = getPlacemark(\n      placemarks[j],\n      styleIndex,\n      styleMapIndex,\n      styleByHash\n    );\n    if (feature) yield feature;\n  }\n}\n\nexport function kml(doc) {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(doc)),\n  };\n}\n"],"names":["nodeVal","x","normalize","textContent","attributeNames","getLineStyle","extensions","style","lineStyle","get1","color","opacity","parseFloat","width","stroke","isNaN","getMulti","ys","o","n","k","length","getProperties","node","prop","getElementsByTagNameNS","i","extension","parentNode","tagName","replace","links","getElementsByTagName","push","Object","assign","href","getAttribute","y","coordPair","ll","ele","heartRate","time","e","result","coordinates","map","r","filter","forEach","name","raw","v","getRoute","line","getPoints","type","properties","geometry","pointname","pts","times","l","extendedValues","c","Array","fill","getTrack","segments","track","s","coordTimes","gpxGen","doc","tracks","routes","waypoints","feature","removeSpace","trimSpace","splitSpace","okhash","h","charCodeAt","coord1","split","coord","xml2str","undefined","xml","output","attributes","value","childNodes","nodeName","nodeValue","trim","geotypes","kmlColor","elem","prefix","colorProp","substr","parseInt","numericProperty","source","target","val","gxCoords","root","elems","coords","timeElems","j","getPlacemark","styleIndex","styleMapIndex","styleByHash","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","rings","address","styleUrl","description","timeSpan","timeStamp","extendedData","iconStyle","labelStyle","polyStyle","visibility","styleHash","styleMapHash","normal","begin","end","timespan","timestamp","hotspot","left","top","icon","outline","datas","simpleDatas","geometries","id","kmlGen","placemarks","styles","styleMaps","hash","toString","pairs","pairsMap","m","features","from"],"mappings":"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"}