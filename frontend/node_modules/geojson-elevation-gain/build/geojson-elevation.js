"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.getElevationGain = exports.computeElevationGain = exports.movingAverageWithWindow = exports.sma = void 0;

var sma = function sma(arr, range, precision) {
  if (!Array.isArray(arr)) {
    throw TypeError('expected first argument to be an array');
  }

  precision = precision || 2;
  var num = range || arr.length;
  var res = [];
  var len = arr.length + 1;
  var idx = num - 1;

  while (++idx < len) {
    var value = avg(arr, idx, num);
    res.push(round(value, precision));
  }

  return res;
};

exports.sma = sma;

function round(value, decimals) {
  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
}
/**
 * Create an average for the specified range.
 *
 * @param  {Array} `arr` Array to pull the range from.
 * @param  {Number} `idx` Index of element being calculated
 * @param  {Number} `range` Size of range to calculate.
 * @return {Number} Average of range.
 */


function avg(arr, idx, range) {
  return sum(arr.slice(idx - range, idx)) / range;
}
/**
 * Calculate the sum of an array.
 * @param  {Array} `arr` Array
 * @return {Number} Sum
 */


function sum(arr) {
  var len = arr.length;
  var num = 0;

  while (len--) {
    num += Number(arr[len]);
  }

  return num;
}

var movingAverageWithWindow = function movingAverageWithWindow(numberOfPoints) {
  return function (el, index, array) {
    var center = Math.floor(numberOfPoints / 2);
    var lowerBound = index - center;
    var upperBound = index + center + 1;

    if (index < center) {
      return el;
    }

    if (upperBound > array.length) {
      upperBound = array.length;
    }

    var acc = 0;
    var windowing = array.slice(lowerBound, upperBound);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = windowing[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var ele = _step.value;
        acc += ele;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return acc / numberOfPoints;
  };
};

exports.movingAverageWithWindow = movingAverageWithWindow;

var computeElevationGain = function computeElevationGain(accumulator, currentValue, index, array) {
  var previousValue = array[index - 1];
  var delta = currentValue - previousValue; // Take only positive value

  if (delta > 0) {
    accumulator += delta;
  }

  return accumulator;
};

exports.computeElevationGain = computeElevationGain;

var getElevationGain = function getElevationGain(geojson, numberOfPoints) {
  var coords = [];

  if (geojson.geometry) {
    coords = geojson.geometry.coordinates;
  } else {
    coords = geojson.coordinates;
  }

  var elevations = coords.map(function (x) {
    return x[2];
  });
  var smaElevations = sma(elevations, numberOfPoints, 2);
  return Math.round(smaElevations.reduce(computeElevationGain, 0));
};

exports.getElevationGain = getElevationGain;
var _default = {
  movingAverageWithWindow: movingAverageWithWindow,
  computeElevationGain: computeElevationGain,
  getElevationGain: getElevationGain,
  sma: sma
};
exports.default = _default;