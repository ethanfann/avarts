{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\n\nexports._dbcs = DBCSCodec;\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++) UNASSIGNED_NODE[i] = UNASSIGNED; // Class DBCSCodec reads and initializes mapping tables.\n\n\nfunction DBCSCodec(codecOptions, iconv) {\n  this.encodingName = codecOptions.encodingName;\n  if (!codecOptions) throw new Error(\"DBCS codec is called without the data.\");\n  if (!codecOptions.table) throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\"); // Load tables.\n\n  var mappingTable = codecOptions.table(); // Decode tables: MBCS -> Unicode.\n  // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n  // Trie root is decodeTables[0].\n  // Values: >=  0 -> unicode character code. can be > 0xFFFF\n  //         == UNASSIGNED -> unknown/unassigned sequence.\n  //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n  //         <= NODE_START -> index of the next node in our trie to process next byte.\n  //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n\n  this.decodeTables = [];\n  this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n  // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n\n  this.decodeTableSeq = []; // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n\n  for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);\n\n  this.defaultCharUnicode = iconv.defaultCharUnicode; // Encode tables: Unicode -> DBCS.\n  // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n  // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n  // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n  //         == UNASSIGNED -> no conversion found. Output a default char.\n  //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n\n  this.encodeTable = []; // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n  // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n  // means end of sequence (needed when one sequence is a strict subsequence of another).\n  // Objects are kept separately from encodeTable to increase performance.\n\n  this.encodeTableSeq = []; // Some chars can be decoded, but need not be encoded.\n\n  var skipEncodeChars = {};\n  if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n    var val = codecOptions.encodeSkipVals[i];\n    if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;\n  } // Use decode trie to recursively fill out encode tables.\n\n  this._fillEncodeTable(0, 0, skipEncodeChars); // Add more encoding pairs when needed.\n\n\n  if (codecOptions.encodeAdd) {\n    for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n  }\n\n  this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n  if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0); // Load & create GB18030 tables when needed.\n\n  if (typeof codecOptions.gb18030 === 'function') {\n    this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n    // Add GB18030 decode tables.\n\n    var thirdByteNodeIdx = this.decodeTables.length;\n    var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n    var fourthByteNodeIdx = this.decodeTables.length;\n    var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n    for (var i = 0x81; i <= 0xFE; i++) {\n      var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n      var secondByteNode = this.decodeTables[secondByteNodeIdx];\n\n      for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n    }\n\n    for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n\n    for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;\n  }\n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder; // Decoder helpers\n\nDBCSCodec.prototype._getDecodeTrieNode = function (addr) {\n  var bytes = [];\n\n  for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);\n\n  if (bytes.length == 0) bytes.push(0);\n  var node = this.decodeTables[0];\n\n  for (var i = bytes.length - 1; i > 0; i--) {\n    // Traverse nodes deeper into the trie.\n    var val = node[bytes[i]];\n\n    if (val == UNASSIGNED) {\n      // Create new node.\n      node[bytes[i]] = NODE_START - this.decodeTables.length;\n      this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n    } else if (val <= NODE_START) {\n      // Existing node.\n      node = this.decodeTables[NODE_START - val];\n    } else throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n  }\n\n  return node;\n};\n\nDBCSCodec.prototype._addDecodeChunk = function (chunk) {\n  // First element of chunk is the hex mbcs code where we start.\n  var curAddr = parseInt(chunk[0], 16); // Choose the decoding node where we'll write our chars.\n\n  var writeTable = this._getDecodeTrieNode(curAddr);\n\n  curAddr = curAddr & 0xFF; // Write all other elements of the chunk to the table.\n\n  for (var k = 1; k < chunk.length; k++) {\n    var part = chunk[k];\n\n    if (typeof part === \"string\") {\n      // String, write as-is.\n      for (var l = 0; l < part.length;) {\n        var code = part.charCodeAt(l++);\n\n        if (0xD800 <= code && code < 0xDC00) {\n          // Decode surrogate\n          var codeTrail = part.charCodeAt(l++);\n          if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error(\"Incorrect surrogate pair in \" + this.encodingName + \" at chunk \" + chunk[0]);\n        } else if (0x0FF0 < code && code <= 0x0FFF) {\n          // Character sequence (our own encoding used)\n          var len = 0xFFF - code + 2;\n          var seq = [];\n\n          for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n\n          writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n          this.decodeTableSeq.push(seq);\n        } else writeTable[curAddr++] = code; // Basic char\n\n      }\n    } else if (typeof part === \"number\") {\n      // Integer, meaning increasing sequence starting with prev character.\n      var charCode = writeTable[curAddr - 1] + 1;\n\n      for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;\n    } else throw new Error(\"Incorrect type '\" + typeof part + \"' given in \" + this.encodingName + \" at chunk \" + chunk[0]);\n  }\n\n  if (curAddr > 0xFF) throw new Error(\"Incorrect chunk in \" + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}; // Encoder helpers\n\n\nDBCSCodec.prototype._getEncodeBucket = function (uCode) {\n  var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n\n  if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n\n  return this.encodeTable[high];\n};\n\nDBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n  else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;\n};\n\nDBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {\n  // Get the root of character tree according to first character of the sequence.\n  var uCode = seq[0];\n\n  var bucket = this._getEncodeBucket(uCode);\n\n  var low = uCode & 0xFF;\n  var node;\n\n  if (bucket[low] <= SEQ_START) {\n    // There's already a sequence with  - use it.\n    node = this.encodeTableSeq[SEQ_START - bucket[low]];\n  } else {\n    // There was no sequence object - allocate a new one.\n    node = {};\n    if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n\n    bucket[low] = SEQ_START - this.encodeTableSeq.length;\n    this.encodeTableSeq.push(node);\n  } // Traverse the character tree, allocating new nodes as needed.\n\n\n  for (var j = 1; j < seq.length - 1; j++) {\n    var oldVal = node[uCode];\n    if (typeof oldVal === 'object') node = oldVal;else {\n      node = node[uCode] = {};\n      if (oldVal !== undefined) node[DEF_CHAR] = oldVal;\n    }\n  } // Set the leaf to given dbcsCode.\n\n\n  uCode = seq[seq.length - 1];\n  node[uCode] = dbcsCode;\n};\n\nDBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {\n  var node = this.decodeTables[nodeIdx];\n\n  for (var i = 0; i < 0x100; i++) {\n    var uCode = node[i];\n    var mbCode = prefix + i;\n    if (skipEncodeChars[mbCode]) continue;\n    if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n  }\n}; // == Encoder ==================================================================\n\n\nfunction DBCSEncoder(options, codec) {\n  // Encoder state\n  this.leadSurrogate = -1;\n  this.seqObj = undefined; // Static data\n\n  this.encodeTable = codec.encodeTable;\n  this.encodeTableSeq = codec.encodeTableSeq;\n  this.defaultCharSingleByte = codec.defCharSB;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function (str) {\n  var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n      leadSurrogate = this.leadSurrogate,\n      seqObj = this.seqObj,\n      nextChar = -1,\n      i = 0,\n      j = 0;\n\n  while (true) {\n    // 0. Get next character.\n    if (nextChar === -1) {\n      if (i == str.length) break;\n      var uCode = str.charCodeAt(i++);\n    } else {\n      var uCode = nextChar;\n      nextChar = -1;\n    } // 1. Handle surrogates.\n\n\n    if (0xD800 <= uCode && uCode < 0xE000) {\n      // Char is one of surrogates.\n      if (uCode < 0xDC00) {\n        // We've got lead surrogate.\n        if (leadSurrogate === -1) {\n          leadSurrogate = uCode;\n          continue;\n        } else {\n          leadSurrogate = uCode; // Double lead surrogate found.\n\n          uCode = UNASSIGNED;\n        }\n      } else {\n        // We've got trail surrogate.\n        if (leadSurrogate !== -1) {\n          uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n          leadSurrogate = -1;\n        } else {\n          // Incomplete surrogate pair - only trail surrogate found.\n          uCode = UNASSIGNED;\n        }\n      }\n    } else if (leadSurrogate !== -1) {\n      // Incomplete surrogate pair - only lead surrogate found.\n      nextChar = uCode;\n      uCode = UNASSIGNED; // Write an error, then current char.\n\n      leadSurrogate = -1;\n    } // 2. Convert uCode character.\n\n\n    var dbcsCode = UNASSIGNED;\n\n    if (seqObj !== undefined && uCode != UNASSIGNED) {\n      // We are in the middle of the sequence\n      var resCode = seqObj[uCode];\n\n      if (typeof resCode === 'object') {\n        // Sequence continues.\n        seqObj = resCode;\n        continue;\n      } else if (typeof resCode == 'number') {\n        // Sequence finished. Write it.\n        dbcsCode = resCode;\n      } else if (resCode == undefined) {\n        // Current character is not part of the sequence.\n        // Try default character for this sequence\n        resCode = seqObj[DEF_CHAR];\n\n        if (resCode !== undefined) {\n          dbcsCode = resCode; // Found. Write it.\n\n          nextChar = uCode; // Current character will be written too in the next iteration.\n        } else {// TODO: What if we have no default? (resCode == undefined)\n            // Then, we should write first char of the sequence as-is and try the rest recursively.\n            // Didn't do it for now because no encoding has this situation yet.\n            // Currently, just skip the sequence and write current char.\n          }\n      }\n\n      seqObj = undefined;\n    } else if (uCode >= 0) {\n      // Regular character\n      var subtable = this.encodeTable[uCode >> 8];\n      if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];\n\n      if (dbcsCode <= SEQ_START) {\n        // Sequence start\n        seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];\n        continue;\n      }\n\n      if (dbcsCode == UNASSIGNED && this.gb18030) {\n        // Use GB18030 algorithm to find character(s) to write.\n        var idx = findIdx(this.gb18030.uChars, uCode);\n\n        if (idx != -1) {\n          var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);\n          dbcsCode = dbcsCode % 12600;\n          newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);\n          dbcsCode = dbcsCode % 1260;\n          newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);\n          dbcsCode = dbcsCode % 10;\n          newBuf[j++] = 0x30 + dbcsCode;\n          continue;\n        }\n      }\n    } // 3. Write dbcsCode character.\n\n\n    if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;\n\n    if (dbcsCode < 0x100) {\n      newBuf[j++] = dbcsCode;\n    } else if (dbcsCode < 0x10000) {\n      newBuf[j++] = dbcsCode >> 8; // high byte\n\n      newBuf[j++] = dbcsCode & 0xFF; // low byte\n    } else {\n      newBuf[j++] = dbcsCode >> 16;\n      newBuf[j++] = dbcsCode >> 8 & 0xFF;\n      newBuf[j++] = dbcsCode & 0xFF;\n    }\n  }\n\n  this.seqObj = seqObj;\n  this.leadSurrogate = leadSurrogate;\n  return newBuf.slice(0, j);\n};\n\nDBCSEncoder.prototype.end = function () {\n  if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.\n\n  var newBuf = Buffer.alloc(10),\n      j = 0;\n\n  if (this.seqObj) {\n    // We're in the sequence.\n    var dbcsCode = this.seqObj[DEF_CHAR];\n\n    if (dbcsCode !== undefined) {\n      // Write beginning of the sequence.\n      if (dbcsCode < 0x100) {\n        newBuf[j++] = dbcsCode;\n      } else {\n        newBuf[j++] = dbcsCode >> 8; // high byte\n\n        newBuf[j++] = dbcsCode & 0xFF; // low byte\n      }\n    } else {// See todo above.\n      }\n\n    this.seqObj = undefined;\n  }\n\n  if (this.leadSurrogate !== -1) {\n    // Incomplete surrogate pair - only lead surrogate found.\n    newBuf[j++] = this.defaultCharSingleByte;\n    this.leadSurrogate = -1;\n  }\n\n  return newBuf.slice(0, j);\n}; // Export for testing\n\n\nDBCSEncoder.prototype.findIdx = findIdx; // == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n  // Decoder state\n  this.nodeIdx = 0;\n  this.prevBuf = Buffer.alloc(0); // Static data\n\n  this.decodeTables = codec.decodeTables;\n  this.decodeTableSeq = codec.decodeTableSeq;\n  this.defaultCharUnicode = codec.defaultCharUnicode;\n  this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function (buf) {\n  var newBuf = Buffer.alloc(buf.length * 2),\n      nodeIdx = this.nodeIdx,\n      prevBuf = this.prevBuf,\n      prevBufOffset = this.prevBuf.length,\n      seqStart = -this.prevBuf.length,\n      // idx of the start of current parsed sequence.\n  uCode;\n  if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n    prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n\n  for (var i = 0, j = 0; i < buf.length; i++) {\n    var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset]; // Lookup in current trie node.\n\n    var uCode = this.decodeTables[nodeIdx][curByte];\n\n    if (uCode >= 0) {// Normal character, just use it.\n    } else if (uCode === UNASSIGNED) {\n      // Unknown char.\n      // TODO: Callback with seq.\n      //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n      i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n\n      uCode = this.defaultCharUnicode.charCodeAt(0);\n    } else if (uCode === GB18030_CODE) {\n      var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);\n      var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);\n      var idx = findIdx(this.gb18030.gbChars, ptr);\n      uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n    } else if (uCode <= NODE_START) {\n      // Go to next trie node.\n      nodeIdx = NODE_START - uCode;\n      continue;\n    } else if (uCode <= SEQ_START) {\n      // Output a sequence of chars.\n      var seq = this.decodeTableSeq[SEQ_START - uCode];\n\n      for (var k = 0; k < seq.length - 1; k++) {\n        uCode = seq[k];\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n      }\n\n      uCode = seq[seq.length - 1];\n    } else throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte); // Write the character to buffer, handling higher planes using surrogate pair.\n\n\n    if (uCode > 0xFFFF) {\n      uCode -= 0x10000;\n      var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n      newBuf[j++] = uCodeLead & 0xFF;\n      newBuf[j++] = uCodeLead >> 8;\n      uCode = 0xDC00 + uCode % 0x400;\n    }\n\n    newBuf[j++] = uCode & 0xFF;\n    newBuf[j++] = uCode >> 8; // Reset trie node.\n\n    nodeIdx = 0;\n    seqStart = i + 1;\n  }\n\n  this.nodeIdx = nodeIdx;\n  this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n  return newBuf.slice(0, j).toString('ucs2');\n};\n\nDBCSDecoder.prototype.end = function () {\n  var ret = ''; // Try to parse all remaining chars.\n\n  while (this.prevBuf.length > 0) {\n    // Skip 1 character in the buffer.\n    ret += this.defaultCharUnicode;\n    var buf = this.prevBuf.slice(1); // Parse remaining as usual.\n\n    this.prevBuf = Buffer.alloc(0);\n    this.nodeIdx = 0;\n    if (buf.length > 0) ret += this.write(buf);\n  }\n\n  this.nodeIdx = 0;\n  return ret;\n}; // Binary search for GB18030. Returns largest i such that table[i] <= val.\n\n\nfunction findIdx(table, val) {\n  if (table[0] > val) return -1;\n  var l = 0,\n      r = table.length;\n\n  while (l < r - 1) {\n    // always table[l] <= val < table[r]\n    var mid = l + Math.floor((r - l + 1) / 2);\n    if (table[mid] <= val) l = mid;else r = mid;\n  }\n\n  return l;\n}","map":{"version":3,"sources":["/home/ethan/avarts/frontend/node_modules/iconv-lite/encodings/dbcs-codec.js"],"names":["Buffer","require","exports","_dbcs","DBCSCodec","UNASSIGNED","GB18030_CODE","SEQ_START","NODE_START","UNASSIGNED_NODE","Array","DEF_CHAR","i","codecOptions","iconv","encodingName","Error","table","mappingTable","decodeTables","slice","decodeTableSeq","length","_addDecodeChunk","defaultCharUnicode","encodeTable","encodeTableSeq","skipEncodeChars","encodeSkipVals","val","j","from","to","_fillEncodeTable","encodeAdd","uChar","Object","prototype","hasOwnProperty","call","_setEncodeChar","charCodeAt","defCharSB","defaultCharSingleByte","gb18030","thirdByteNodeIdx","thirdByteNode","fourthByteNodeIdx","fourthByteNode","secondByteNodeIdx","secondByteNode","encoder","DBCSEncoder","decoder","DBCSDecoder","_getDecodeTrieNode","addr","bytes","push","node","toString","chunk","curAddr","parseInt","writeTable","k","part","l","code","codeTrail","len","seq","m","charCode","_getEncodeBucket","uCode","high","undefined","dbcsCode","bucket","low","_setEncodeSequence","oldVal","nodeIdx","prefix","mbCode","options","codec","leadSurrogate","seqObj","write","str","newBuf","alloc","nextChar","resCode","subtable","idx","findIdx","uChars","gbChars","Math","floor","end","prevBuf","buf","prevBufOffset","seqStart","concat","curByte","curSeq","ptr","uCodeLead","ret","r","mid"],"mappings":"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","sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),\n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = Buffer.alloc(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = Buffer.alloc(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = Buffer.alloc(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = Buffer.alloc(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"]},"metadata":{},"sourceType":"script"}