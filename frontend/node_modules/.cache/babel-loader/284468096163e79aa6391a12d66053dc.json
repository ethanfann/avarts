{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"safer-buffer\").Buffer; // Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\n\nexports._sbcs = SBCSCodec;\n\nfunction SBCSCodec(codecOptions, iconv) {\n  if (!codecOptions) throw new Error(\"SBCS codec is called without the data.\"); // Prepare char buffer for decoding.\n\n  if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error(\"Encoding '\" + codecOptions.type + \"' has incorrect 'chars' (must be of len 128 or 256)\");\n\n  if (codecOptions.chars.length === 128) {\n    var asciiString = \"\";\n\n    for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);\n\n    codecOptions.chars = asciiString + codecOptions.chars;\n  }\n\n  this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2'); // Encoding buffer.\n\n  var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n  for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n  this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\nfunction SBCSEncoder(options, codec) {\n  this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function (str) {\n  var buf = Buffer.alloc(str.length);\n\n  for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];\n\n  return buf;\n};\n\nSBCSEncoder.prototype.end = function () {};\n\nfunction SBCSDecoder(options, codec) {\n  this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function (buf) {\n  // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n  var decodeBuf = this.decodeBuf;\n  var newBuf = Buffer.alloc(buf.length * 2);\n  var idx1 = 0,\n      idx2 = 0;\n\n  for (var i = 0; i < buf.length; i++) {\n    idx1 = buf[i] * 2;\n    idx2 = i * 2;\n    newBuf[idx2] = decodeBuf[idx1];\n    newBuf[idx2 + 1] = decodeBuf[idx1 + 1];\n  }\n\n  return newBuf.toString('ucs2');\n};\n\nSBCSDecoder.prototype.end = function () {};","map":{"version":3,"sources":["/home/ethan/avarts/frontend/node_modules/iconv-lite/encodings/sbcs-codec.js"],"names":["Buffer","require","exports","_sbcs","SBCSCodec","codecOptions","iconv","Error","chars","length","type","asciiString","i","String","fromCharCode","decodeBuf","from","encodeBuf","alloc","defaultCharSingleByte","charCodeAt","prototype","encoder","SBCSEncoder","decoder","SBCSDecoder","options","codec","write","str","buf","end","newBuf","idx1","idx2","toString"],"mappings":"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","sourcesContent":["\"use strict\";\nvar Buffer = require(\"safer-buffer\").Buffer;\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n    if (!codecOptions)\n        throw new Error(\"SBCS codec is called without the data.\")\n    \n    // Prepare char buffer for decoding.\n    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))\n        throw new Error(\"Encoding '\"+codecOptions.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n    \n    if (codecOptions.chars.length === 128) {\n        var asciiString = \"\";\n        for (var i = 0; i < 128; i++)\n            asciiString += String.fromCharCode(i);\n        codecOptions.chars = asciiString + codecOptions.chars;\n    }\n\n    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');\n    \n    // Encoding buffer.\n    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));\n\n    for (var i = 0; i < codecOptions.chars.length; i++)\n        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n    this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\n\nfunction SBCSEncoder(options, codec) {\n    this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function(str) {\n    var buf = Buffer.alloc(str.length);\n    for (var i = 0; i < str.length; i++)\n        buf[i] = this.encodeBuf[str.charCodeAt(i)];\n    \n    return buf;\n}\n\nSBCSEncoder.prototype.end = function() {\n}\n\n\nfunction SBCSDecoder(options, codec) {\n    this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function(buf) {\n    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n    var decodeBuf = this.decodeBuf;\n    var newBuf = Buffer.alloc(buf.length*2);\n    var idx1 = 0, idx2 = 0;\n    for (var i = 0; i < buf.length; i++) {\n        idx1 = buf[i]*2; idx2 = i*2;\n        newBuf[idx2] = decodeBuf[idx1];\n        newBuf[idx2+1] = decodeBuf[idx1+1];\n    }\n    return newBuf.toString('ucs2');\n}\n\nSBCSDecoder.prototype.end = function() {\n}\n"]},"metadata":{},"sourceType":"script"}