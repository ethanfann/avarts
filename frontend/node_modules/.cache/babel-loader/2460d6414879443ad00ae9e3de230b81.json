{"ast":null,"code":"'use strict';\n/**\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction py2_round(value) {\n  // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values\n  return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);\n}\n\nfunction encode(current, previous, factor) {\n  current = py2_round(current * factor);\n  previous = py2_round(previous * factor);\n  var coordinate = current - previous;\n  coordinate <<= 1;\n\n  if (current - previous < 0) {\n    coordinate = ~coordinate;\n  }\n\n  var output = '';\n\n  while (coordinate >= 0x20) {\n    output += String.fromCharCode((0x20 | coordinate & 0x1f) + 63);\n    coordinate >>= 5;\n  }\n\n  output += String.fromCharCode(coordinate + 63);\n  return output;\n}\n/**\n * Decodes to a [latitude, longitude] coordinates array.\n *\n * This is adapted from the implementation in Project-OSRM.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Array}\n *\n * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n */\n\n\npolyline.decode = function (str, precision) {\n  var index = 0,\n      lat = 0,\n      lng = 0,\n      coordinates = [],\n      shift = 0,\n      result = 0,\n      byte = null,\n      latitude_change,\n      longitude_change,\n      factor = Math.pow(10, Number.isInteger(precision) ? precision : 5); // Coordinates have variable length when encoded, so just keep\n  // track of whether we've hit the end of the string. In each\n  // loop iteration, a single coordinate is decoded.\n\n  while (index < str.length) {\n    // Reset shift, result, and byte\n    byte = null;\n    shift = 0;\n    result = 0;\n\n    do {\n      byte = str.charCodeAt(index++) - 63;\n      result |= (byte & 0x1f) << shift;\n      shift += 5;\n    } while (byte >= 0x20);\n\n    latitude_change = result & 1 ? ~(result >> 1) : result >> 1;\n    shift = result = 0;\n\n    do {\n      byte = str.charCodeAt(index++) - 63;\n      result |= (byte & 0x1f) << shift;\n      shift += 5;\n    } while (byte >= 0x20);\n\n    longitude_change = result & 1 ? ~(result >> 1) : result >> 1;\n    lat += latitude_change;\n    lng += longitude_change;\n    coordinates.push([lat / factor, lng / factor]);\n  }\n\n  return coordinates;\n};\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\n\n\npolyline.encode = function (coordinates, precision) {\n  if (!coordinates.length) {\n    return '';\n  }\n\n  var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5),\n      output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);\n\n  for (var i = 1; i < coordinates.length; i++) {\n    var a = coordinates[i],\n        b = coordinates[i - 1];\n    output += encode(a[0], b[0], factor);\n    output += encode(a[1], b[1], factor);\n  }\n\n  return output;\n};\n\nfunction flipped(coords) {\n  var flipped = [];\n\n  for (var i = 0; i < coords.length; i++) {\n    var coord = coords[i].slice();\n    flipped.push([coord[1], coord[0]]);\n  }\n\n  return flipped;\n}\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\n\n\npolyline.fromGeoJSON = function (geojson, precision) {\n  if (geojson && geojson.type === 'Feature') {\n    geojson = geojson.geometry;\n  }\n\n  if (!geojson || geojson.type !== 'LineString') {\n    throw new Error('Input must be a GeoJSON LineString');\n  }\n\n  return polyline.encode(flipped(geojson.coordinates), precision);\n};\n/**\n * Decodes to a GeoJSON LineString geometry.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Object}\n */\n\n\npolyline.toGeoJSON = function (str, precision) {\n  var coords = polyline.decode(str, precision);\n  return {\n    type: 'LineString',\n    coordinates: flipped(coords)\n  };\n};\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = polyline;\n}","map":{"version":3,"sources":["/home/ethan/avarts/frontend/node_modules/@mapbox/polyline/src/polyline.js"],"names":["polyline","py2_round","value","Math","floor","abs","encode","current","previous","factor","coordinate","output","String","fromCharCode","decode","str","precision","index","lat","lng","coordinates","shift","result","byte","latitude_change","longitude_change","pow","Number","isInteger","length","charCodeAt","push","i","a","b","flipped","coords","coord","slice","fromGeoJSON","geojson","type","geometry","Error","toGeoJSON","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n *\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n *\n * @module polyline\n */\n\nvar polyline = {};\n\nfunction py2_round(value) {\n    // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values\n    return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);\n}\n\nfunction encode(current, previous, factor) {\n    current = py2_round(current * factor);\n    previous = py2_round(previous * factor);\n    var coordinate = current - previous;\n    coordinate <<= 1;\n    if (current - previous < 0) {\n        coordinate = ~coordinate;\n    }\n    var output = '';\n    while (coordinate >= 0x20) {\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\n        coordinate >>= 5;\n    }\n    output += String.fromCharCode(coordinate + 63);\n    return output;\n}\n\n/**\n * Decodes to a [latitude, longitude] coordinates array.\n *\n * This is adapted from the implementation in Project-OSRM.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Array}\n *\n * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n */\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n\n/**\n * Encodes the given [latitude, longitude] coordinates array.\n *\n * @param {Array.<Array.<Number>>} coordinates\n * @param {Number} precision\n * @returns {String}\n */\npolyline.encode = function(coordinates, precision) {\n    if (!coordinates.length) { return ''; }\n\n    var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5),\n        output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);\n\n    for (var i = 1; i < coordinates.length; i++) {\n        var a = coordinates[i], b = coordinates[i - 1];\n        output += encode(a[0], b[0], factor);\n        output += encode(a[1], b[1], factor);\n    }\n\n    return output;\n};\n\nfunction flipped(coords) {\n    var flipped = [];\n    for (var i = 0; i < coords.length; i++) {\n        var coord = coords[i].slice();\n        flipped.push([coord[1], coord[0]]);\n    }\n    return flipped;\n}\n\n/**\n * Encodes a GeoJSON LineString feature/geometry.\n *\n * @param {Object} geojson\n * @param {Number} precision\n * @returns {String}\n */\npolyline.fromGeoJSON = function(geojson, precision) {\n    if (geojson && geojson.type === 'Feature') {\n        geojson = geojson.geometry;\n    }\n    if (!geojson || geojson.type !== 'LineString') {\n        throw new Error('Input must be a GeoJSON LineString');\n    }\n    return polyline.encode(flipped(geojson.coordinates), precision);\n};\n\n/**\n * Decodes to a GeoJSON LineString geometry.\n *\n * @param {String} str\n * @param {Number} precision\n * @returns {Object}\n */\npolyline.toGeoJSON = function(str, precision) {\n    var coords = polyline.decode(str, precision);\n    return {\n        type: 'LineString',\n        coordinates: flipped(coords)\n    };\n};\n\nif (typeof module === 'object' && module.exports) {\n    module.exports = polyline;\n}\n"]},"metadata":{},"sourceType":"script"}