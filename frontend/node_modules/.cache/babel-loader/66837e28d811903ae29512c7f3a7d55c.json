{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst VALUE = 'value';\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners({\n  ref\n}, shouldAttachChangeEvent, handleChange) {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nvar isArray = value => Array.isArray(value);\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar isKey = value => !isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = input => {\n  const result = [];\n  input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\n    result.push(mathQuote ? originalString.replace(/\\\\(\\\\)?/g, '$1') : mathNumber || match);\n  });\n  return result;\n};\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = data => Object.entries(data).reduce((previous, [key, value]) => {\n  if (!isKey(key)) {\n    set(previous, key, value);\n    return previous;\n  }\n\n  return Object.assign(Object.assign({}, previous), {\n    [key]: value\n  });\n}, {});\n\nvar isUndefined = val => val === undefined;\n\nvar unique = value => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\n  const result = unique(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, unmountFieldsStateRef) {\n  const field = fieldsRef.current[name];\n\n  if (field) {\n    const {\n      ref: {\n        value\n      },\n      ref\n    } = field;\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (unmountFieldsStateRef) {\n    return unmountFieldsStateRef.current[name];\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, unmountFieldsStateRef, shouldUnregister, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name,\n      type\n    },\n    mutationWatcher\n  } = field;\n  const fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const {\n      options\n    } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      unique(options).forEach((option, index) => {\n        const {\n          ref,\n          mutationWatcher\n        } = option;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !unique(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fieldsRef.current[name];\n  }\n}\n\nvar isString = value => typeof value === 'string';\n\nfunction deepMerge(target, source) {\n  if (!isObject(target) || !isObject(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    if (isObject(targetValue) && isObject(sourceValue)) {\n      target[key] = deepMerge(targetValue, sourceValue);\n    } else {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n\nvar getFieldsValues = (fieldsRef, unmountFieldsStateRef, search) => {\n  const output = {};\n\n  for (const name in fieldsRef.current) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fieldsRef, name);\n    }\n  }\n\n  return deepMerge(transformToNestObject((unmountFieldsStateRef || {}).current || {}), transformToNestObject(output));\n};\n\nvar isSameError = (error, {\n  type,\n  types = {},\n  message\n}) => isObject(error) && error.type === type && error.message === message && Object.keys(error.types || {}).length === Object.keys(types).length && Object.entries(error.types || {}).every(([key, value]) => types[key] === value);\n\nfunction shouldRenderBasedOnError({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name)) {\n    return false;\n  }\n\n  if (isFormValid !== isFieldValid || !isFormValid && !existFieldError || isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name)) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nconst isValueMessage = value => isObject(value) && !isRegex(value);\n\nvar getValueAndMessage = validationData => isValueMessage(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n\n  return {};\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, {\n  ref,\n  ref: {\n    type,\n    value\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, unmountFieldsStateRef) => {\n  const fields = fieldsRef.current;\n  const name = ref.name;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value: requiredValue,\n      message: requiredMessage\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? (fields[name].options || [])[0].ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\n  const getInnerPath = (value, key, isObject) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values).map(([key, value]) => getInnerPath(value, key, isObject(values))).flat(Infinity);\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nfunction deepEqual(object1 = [], object2 = []) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n\n    if ((isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2)) ? !deepEqual(val1, val2) : val1 !== val2) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\n  const observer = new MutationObserver(() => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const errorsRef = useRef({});\n  const touchedFieldsRef = useRef({});\n  const fieldArrayDefaultValues = useRef({});\n  const dirtyFieldsRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const watchFieldsHookRef = useRef({});\n  const watchFieldsHookRenderRef = useRef({});\n  const fieldsWithValidationRef = useRef(new Set());\n  const validFieldsRef = useRef(new Set());\n  const isValidRef = useRef(true);\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const isSubmittedRef = useRef(false);\n  const isDirtyRef = useRef(false);\n  const submitCountRef = useRef(0);\n  const isSubmittingRef = useRef(false);\n  const handleChangeRef = useRef();\n  const unmountFieldsStateRef = useRef({});\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n  const [, render] = useState();\n  const modeRef = useRef(modeChecker(mode));\n  const {\n    current: {\n      isOnSubmit,\n      isOnTouch\n    }\n  } = modeRef;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const {\n    current: {\n      isOnBlur: isReValidateOnBlur,\n      isOnChange: isReValidateOnChange\n    }\n  } = useRef(modeChecker(reValidateMode));\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  const reRender = useCallback(() => !isUnMount.current && render({}), []);\n  const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false) => {\n    let shouldReRender = shouldRender || shouldRenderBasedOnError({\n      errors: errorsRef.current,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(errorsRef.current, name);\n\n    if (isEmptyObject(error)) {\n      if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\n        validFieldsRef.current.add(name);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      errorsRef.current = unset(errorsRef.current, name);\n    } else {\n      validFieldsRef.current.delete(name);\n      shouldReRender = shouldReRender || !previousError || !isSameError(previousError, error[name]);\n      set(errorsRef.current, name, error[name]);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n      reRender();\n      return true;\n    }\n  }, []);\n  const setFieldValue = useCallback(({\n    ref,\n    options\n  }, rawValue) => {\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = String(value).includes(checkboxRef.value)) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  const setDirty = useCallback(name => {\n    const {\n      isDirty,\n      dirtyFields\n    } = readFormStateRef.current;\n\n    if (!fieldsRef.current[name] || !isDirty && !dirtyFields) {\n      return false;\n    }\n\n    const isFieldDirty = defaultValuesAtRenderRef.current[name] !== getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n    const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const previousIsDirty = isDirtyRef.current;\n\n    if (isFieldDirty) {\n      set(dirtyFieldsRef.current, name, true);\n    } else {\n      unset(dirtyFieldsRef.current, name);\n    }\n\n    isDirtyRef.current = isFieldArray && !deepEqual(get(getValues(), getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name))) || !isEmptyObject(dirtyFieldsRef.current);\n    return isDirty && previousIsDirty !== isDirtyRef.current || dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name);\n  }, []);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    if (fieldsRef.current[name]) {\n      const error = await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], unmountFieldsStateRef);\n      shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n      return isEmptyObject(error);\n    }\n\n    return false;\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async payload => {\n    const {\n      errors\n    } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = isValidRef.current;\n    isValidRef.current = isEmptyObject(errors);\n\n    if (isArray(payload)) {\n      const isInputsValid = payload.map(name => {\n        const error = get(errors, name);\n\n        if (error) {\n          set(errorsRef.current, name, error);\n        } else {\n          unset(errorsRef.current, name);\n        }\n\n        return !error;\n      }).every(Boolean);\n      reRender();\n      return isInputsValid;\n    } else {\n      const error = get(errors, payload);\n      shouldRenderBaseOnError(payload, error ? {\n        [payload]: error\n      } : {}, previousFormIsValid !== isValidRef.current);\n      return !error;\n    }\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const trigger = useCallback(async name => {\n    const fields = name || Object.keys(fieldsRef.current);\n\n    if (resolverRef.current) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n\n    if (isArray(fields)) {\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, true)));\n      reRender();\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields);\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = useCallback((name, value, {\n    shouldDirty,\n    shouldValidate\n  }) => {\n    getPath(name, value).forEach(fieldName => {\n      const data = {};\n      const field = fieldsRef.current[fieldName];\n\n      if (field) {\n        set(data, name, value);\n        setFieldValue(field, get(data, fieldName));\n\n        if (shouldDirty) {\n          setDirty(fieldName);\n        }\n\n        if (shouldValidate) {\n          trigger(fieldName);\n        }\n      }\n    });\n  }, [trigger, setFieldValue, setDirty]);\n  const setInternalValue = useCallback((name, value, config) => {\n    if (fieldsRef.current[name]) {\n      setFieldValue(fieldsRef.current[name], value);\n      return config.shouldDirty && setDirty(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n    }\n\n    if (!shouldUnregister) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n\n    return true;\n  }, [setDirty, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name, found = true) => {\n    if (!isEmptyObject(watchFieldsHookRef.current)) {\n      for (const key in watchFieldsHookRef.current) {\n        if (!name || watchFieldsHookRef.current[key].has(name) || watchFieldsHookRef.current[key].has(getFieldArrayParentName(name)) || !watchFieldsHookRef.current[key].size) {\n          watchFieldsHookRenderRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config = {}) {\n    const shouldRender = setInternalValue(name, value, config) || isFieldWatched(name);\n    renderWatchedInputs(name);\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    if (config.shouldValidate) {\n      trigger(name);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({\n    type,\n    target\n  }) => {\n    const name = target.name;\n    const field = fieldsRef.current[name];\n    let error;\n\n    if (field) {\n      const isBlurEvent = type === EVENTS.BLUR;\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isReValidateOnChange,\n        isReValidateOnBlur,\n        isSubmitted: isSubmittedRef.current,\n        isTouched: !!get(touchedFieldsRef.current, name)\n      }, modeRef.current));\n      let shouldRender = setDirty(name) || isFieldWatched(name);\n\n      if (isBlurEvent && !get(touchedFieldsRef.current, name) && readFormStateRef.current.touched) {\n        set(touchedFieldsRef.current, name, true);\n        shouldRender = true;\n      }\n\n      if (shouldSkipValidation) {\n        renderWatchedInputs(name);\n        return shouldRender && reRender();\n      }\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n        const previousFormIsValid = isValidRef.current;\n        isValidRef.current = isEmptyObject(errors);\n        error = get(errors, name) ? {\n          [name]: get(errors, name)\n        } : {};\n\n        if (previousFormIsValid !== isValidRef.current) {\n          shouldRender = true;\n        }\n      } else {\n        error = await validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef);\n      }\n\n      renderWatchedInputs(name);\n\n      if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n        reRender();\n      }\n    }\n  };\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, unmountFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      return payload.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: getFieldValue(fieldsRef, name, unmountFieldsStateRef)\n      }), {});\n    }\n\n    return getFieldsValues(fieldsRef, unmountFieldsStateRef);\n  }\n\n  const validateResolver = useCallback(async (values = {}) => {\n    const {\n      errors\n    } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = isValidRef.current;\n    isValidRef.current = isEmptyObject(errors);\n\n    if (previousFormIsValid !== isValidRef.current) {\n      reRender();\n    }\n  }, [isValidateAllFieldCriteria]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, unmountFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field && (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) || forceDelete)) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister) {\n        [errorsRef, touchedFieldsRef, dirtyFieldsRef, defaultValuesAtRenderRef].forEach(data => unset(data.current, field.ref.name));\n        [fieldsWithValidationRef, validFieldsRef].forEach(data => data.current.delete(field.ref.name));\n\n        if (readFormStateRef.current.isValid || readFormStateRef.current.touched || readFormStateRef.current.isDirty) {\n          isDirtyRef.current = !isEmptyObject(dirtyFieldsRef.current);\n          reRender();\n\n          if (resolverRef.current) {\n            validateResolver();\n          }\n        }\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    if (name) {\n      (isArray(name) ? name : [name]).forEach(inputName => unset(errorsRef.current, inputName));\n    } else {\n      errorsRef.current = {};\n    }\n\n    reRender();\n  }\n\n  function setError(name, error) {\n    isValidRef.current = false;\n    set(errorsRef.current, name, Object.assign(Object.assign({}, error), {\n      ref: (fieldsRef.current[name] || {}).ref\n    }));\n    reRender();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? watchFieldsHookRef.current[watchId] : watchFieldsRef.current;\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    const fieldValues = getFieldsValues(fieldsRef, unmountFieldsStateRef, fieldNames);\n\n    if (isString(fieldNames)) {\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    if (isUndefined(watchId)) {\n      isWatchAllRef.current = true;\n    }\n\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    (isArray(name) ? name : [name]).forEach(fieldName => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\n  }\n\n  function registerFieldRef(ref, validateOptions = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute:', ref);\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+]\\.\\\\w+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\". https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n\n    const compareRef = currentRef => isWeb && (!isHTMLElement(ref) || currentRef === ref);\n\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? isArray(field.options) && unique(field.options).find(option => {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...unique(field && field.options || []), {\n          ref,\n          mutationWatcher\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), {\n        mutationWatcher\n      });\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(get(unmountFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : unmountFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef).then(error => {\n          const previousFormIsValid = isValidRef.current;\n          isEmptyObject(error) ? validFieldsRef.current.add(name) : isValidRef.current = false;\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      const fieldValue = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return ref => ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors = {};\n    let fieldValues = getFieldsValues(fieldsRef, unmountFieldsStateRef);\n\n    if (readFormStateRef.current.isSubmitting) {\n      isSubmittingRef.current = true;\n      reRender();\n    }\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n        errorsRef.current = errors;\n        fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fieldsRef.current)) {\n          if (field) {\n            const {\n              ref: {\n                name\n              }\n            } = field;\n            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef);\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              validFieldsRef.current.delete(name);\n            } else if (fieldsWithValidationRef.current.has(name)) {\n              unset(errorsRef.current, name);\n              validFieldsRef.current.add(name);\n            }\n          }\n        }\n      }\n\n      if (isEmptyObject(fieldErrors) && Object.keys(errorsRef.current).every(name => Object.keys(fieldsRef.current).includes(name))) {\n        errorsRef.current = {};\n        reRender();\n        await onValid(fieldValues, e);\n      } else {\n        errorsRef.current = Object.assign(Object.assign({}, errorsRef.current), fieldErrors);\n\n        if (onInvalid) {\n          await onInvalid(fieldErrors, e);\n        }\n\n        if (shouldFocusError) {\n          focusOnErrorField(fieldsRef.current, fieldErrors);\n        }\n      }\n    } finally {\n      isSubmittedRef.current = true;\n      isSubmittingRef.current = false;\n      submitCountRef.current = submitCountRef.current + 1;\n      reRender();\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields\n  }) => {\n    if (!errors) {\n      errorsRef.current = {};\n    }\n\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n\n    if (!isDirty) {\n      isDirtyRef.current = false;\n    }\n\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = {};\n    }\n\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValues.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n\n  const reset = (values, omitResetState = {}) => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = values || Object.assign({}, defaultValuesRef.current);\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    unmountFieldsStateRef.current = shouldUnregister ? {} : values || {};\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    resetRefs(omitResetState);\n    reRender();\n  };\n\n  useEffect(() => {\n    isUnMount.current = false;\n    return () => {\n      isUnMount.current = true;\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current && Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    isValidRef.current = validFieldsRef.current.size >= fieldsWithValidationRef.current.size && isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isDirty: isDirtyRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit ? isSubmittedRef.current && isEmptyObject(errorsRef.current) : isValidRef.current\n  };\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [reRender, setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, []),\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (process.env.NODE_ENV !== 'production' && prop === 'isValid' && isOnSubmit) {\n          console.warn('📋 `formState.isValid` is applicable with `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState\n  };\n  const control = Object.assign({\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    reRender,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    isSubmittedRef,\n    readFormStateRef,\n    defaultValuesRef,\n    unmountFieldsStateRef,\n    validateResolver: resolver ? validateResolver : undefined\n  }, commonProps);\n  return Object.assign({\n    watch,\n    control,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: errorsRef.current\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var {\n    children\n  } = _a,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\n\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return unique(data);\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(isArray(value) ? value : [value || undefined]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(isArray(value) ? value : [value || undefined]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    const object = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nconst filterBooleanArray = value => isArray(value) ? value.map(mapValueToBoolean).flat() : mapValueToBoolean(value);\n\nconst appendId = (value, keyName) => Object.assign({\n  [keyName]: generateId()\n}, isObject(value) ? value : {\n  value\n});\n\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map(value => appendId(value, keyName));\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id'\n}) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop.');\n    }\n\n    if (!name) {\n      console.warn('📋 useFieldArray is missing `name` attribute.');\n    }\n  }\n\n  const focusIndexRef = useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    reRender,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    errorsRef,\n    dirtyFieldsRef,\n    isDirtyRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValues,\n    validateResolver,\n    renderWatchedInputs,\n    getValues\n  } = control || methods.control;\n  let shouldRender;\n\n  const getDefaultValues = () => [...(get(fieldArrayDefaultValues.current, name) || get(defaultValuesRef.current, name) || [])];\n\n  const memoizedDefaultValues = useRef(getDefaultValues());\n  const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = useRef(fields);\n  const rootParentName = getFieldArrayParentName(name);\n\n  const getCurrentFieldsValues = () => get(getValues() || {}, name, allFields.current).map((item, index) => Object.assign(Object.assign({}, allFields.current[index]), item));\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValues.current, name) && rootParentName) {\n    set(fieldArrayDefaultValues.current, rootParentName, get(defaultValuesRef.current, rootParentName));\n  }\n\n  const appendValueWithKey = values => values.map(value => appendId(value, keyName));\n\n  const setFieldAndValidState = fieldsValues => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const shouldRenderFieldArray = shouldRender => {\n    renderWatchedInputs(name);\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty || readFormStateRef.current.isValid) && !isWatchAllRef.current) {\n      shouldRender = true;\n    }\n\n    shouldRender && reRender();\n  };\n\n  const resetFields = flagOrFields => {\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      isDirtyRef.current = isUndefined(flagOrFields) || !deepEqual(flagOrFields.map((_a = {}) => {\n        var _b = keyName,\n            omitted = _a[_b],\n            rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        return rest;\n      }), get(defaultValuesRef.current, name, []));\n    }\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key], true);\n      }\n    }\n  };\n\n  const append = (value, shouldFocus = true) => {\n    shouldRender = false;\n    setFieldAndValidState([...allFields.current, ...(isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)])]);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(dirtyFieldsRef.current, name, [...(get(dirtyFieldsRef.current, name) || fillEmptyArray(fields.slice(0, 1))), ...filterBooleanArray(value)]);\n      isDirtyRef.current = true;\n      shouldRender = true;\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const prepend$1 = (value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    shouldRender = false;\n    setFieldAndValidState(prepend(getCurrentFieldsValues(), isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields();\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(errorsRef.current, name, prepend(get(errorsRef.current, name), emptyArray));\n    }\n\n    if (readFormStateRef.current.touched && get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, prepend(get(touchedFieldsRef.current, name), emptyArray));\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      set(dirtyFieldsRef.current, name, prepend(get(dirtyFieldsRef.current, name) || [], filterBooleanArray(value)));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    shouldRender = false;\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields(removeArrayAt(fieldValues, index));\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(errorsRef.current, name, removeArrayAt(get(errorsRef.current, name), index));\n\n      if (!unique(get(errorsRef.current, name, [])).length) {\n        unset(errorsRef.current, name);\n      }\n    }\n\n    if (readFormStateRef.current.touched && get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, removeArrayAt(get(touchedFieldsRef.current, name), index));\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && get(dirtyFieldsRef.current, name)) {\n      set(dirtyFieldsRef.current, name, removeArrayAt(get(dirtyFieldsRef.current, name), index));\n\n      if (!unique(get(dirtyFieldsRef.current, name, [])).length) {\n        unset(dirtyFieldsRef.current, name);\n      }\n\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.isValid && !validateResolver) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n\n        if (!isFound) {\n          continue;\n        }\n\n        for (const key in fields[fieldIndex]) {\n          const getFieldName = (index = 0) => `${name}[${fieldIndex - index}].${key}`;\n\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(getFieldName());\n            fieldsWithValidationRef.current.delete(getFieldName());\n          } else {\n            if (validFieldsRef.current.has(getFieldName())) {\n              validFieldsRef.current.add(getFieldName(1));\n            }\n\n            if (fieldsWithValidationRef.current.has(getFieldName())) {\n              fieldsWithValidationRef.current.add(getFieldName(1));\n            }\n          }\n        }\n      }\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const insert$1 = (index, value, shouldFocus = true) => {\n    shouldRender = false;\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(insert(fieldValues, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\n    resetFields(insert(fieldValues, index));\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(errorsRef.current, name, insert(get(errorsRef.current, name), index, emptyArray));\n    }\n\n    if (readFormStateRef.current.touched && get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, insert(get(touchedFieldsRef.current, name), index, emptyArray));\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && get(dirtyFieldsRef.current, name)) {\n      set(dirtyFieldsRef.current, name, insert(get(dirtyFieldsRef.current, name), index, filterBooleanArray(value)));\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    shouldRender = false;\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    setFieldAndValidState([...fieldValues]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      swapArrayAt(get(errorsRef.current, name), indexA, indexB);\n    }\n\n    if (readFormStateRef.current.touched && get(touchedFieldsRef.current, name)) {\n      swapArrayAt(get(touchedFieldsRef.current, name), indexA, indexB);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && get(dirtyFieldsRef.current, name)) {\n      swapArrayAt(get(dirtyFieldsRef.current, name), indexA, indexB);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const move = (from, to) => {\n    shouldRender = false;\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    setFieldAndValidState([...fieldValues]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      moveArrayAt(get(errorsRef.current, name), from, to);\n    }\n\n    if (readFormStateRef.current.touched && get(touchedFieldsRef.current, name)) {\n      moveArrayAt(get(touchedFieldsRef.current, name), from, to);\n      shouldRender = true;\n    }\n\n    if ((readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) && get(dirtyFieldsRef.current, name)) {\n      moveArrayAt(get(dirtyFieldsRef.current, name), from, to);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(() => {\n    const defaultValues = get(fieldArrayDefaultValues.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValues.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          reRender();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name, fieldArrayDefaultValues, reRender, fieldsRef, watchFieldsRef, isWatchAllRef]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    resetFunctions[name] = reset;\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNamesRef.current.delete(name);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [fields, name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nfunction useWatch({\n  control,\n  name,\n  defaultValue\n}) {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop.');\n    }\n\n    if (name === '') {\n      console.warn('📋 useWatch is missing `name` attribute.');\n    }\n  }\n\n  const {\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    watchInternal,\n    defaultValuesRef\n  } = control || methods.control;\n  const [value, setValue] = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue);\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  const updateWatchValue = useCallback(() => setValue(watchInternal(name, defaultValueRef.current, idRef.current)), [setValue, watchInternal, defaultValueRef, name, idRef]);\n  useEffect(() => {\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = watchFieldsHookRenderRef.current;\n    const watchFieldsHook = watchFieldsHookRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, updateWatchValue, watchFieldsHookRenderRef, watchFieldsHookRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = event => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nconst Controller = _a => {\n  var {\n    name,\n    rules,\n    as,\n    render,\n    defaultValue,\n    control,\n    onFocus\n  } = _a,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error('📋 Controller is missing `control` prop.');\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    isSubmittedRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    reRender,\n    fieldsRef,\n    fieldArrayNamesRef,\n    unmountFieldsStateRef\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(get(unmountFieldsStateRef.current, name)) && isNotFieldArray ? unmountFieldsStateRef.current[name] : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const [value, setInputStateValue] = useState(getInitialValue());\n  const valueRef = useRef(value);\n  const onFocusRef = useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn('📋 Controller `defaultValue` or useForm `defaultValues` is missing.');\n    }\n\n    if (as && render) {\n      console.warn('📋 Should use either `as` or `render` prop.');\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`.');\n    }\n  }\n\n  const shouldValidate = isBlurEvent => !skipValidation(Object.assign({\n    isBlurEvent,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isSubmitted: isSubmittedRef.current\n  }, mode));\n\n  const commonTask = ([event]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn('📋 Field is missing `name` prop.');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n\n        get() {\n          return valueRef.current;\n        }\n\n      }), rules);\n\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [fieldsRef, rules, name, onFocusRef, register]);\n  useEffect(() => () => {\n    !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n  }, [unregister, name, fieldArrayNamesRef]);\n  useEffect(() => {\n    registerField();\n  }, [registerField]); // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (readFormStateRef.current.touched && !get(touchedFieldsRef.current, name)) {\n      set(touchedFieldsRef.current, name, true);\n      reRender();\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event) => setValue(name, commonTask(event), {\n    shouldValidate: shouldValidate(),\n    shouldDirty: true\n  });\n\n  const props = Object.assign(Object.assign({}, rest), {\n    onChange,\n    onBlur,\n    name,\n    value\n  });\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render({\n    onChange,\n    onBlur,\n    value,\n    name\n  }) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isArray.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/unique.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/utils/isString.ts","../src/utils/deepMerge.ts","../src/logic/getFieldsValues.ts","../src/utils/isSameError.ts","../src/logic/shouldRenderBasedOnError.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/isPrimitive.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/logic/deepEqual.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/filterBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","React.useRef","React.useState","React.useCallback","React.useEffect","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types/form';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types/form';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","export default <T>(value: unknown): value is T[] => Array.isArray(value);\n","import isNullOrUndefined from './isNullOrUndefined';\nimport isArray from './isArray';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","import isArray from './isArray';\n\nexport default (value: [] | string) =>\n  !isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (input: string): (string | number)[] => {\n  const result: (string | number)[] = [];\n\n  input.replace(\n    /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,\n    (\n      match: string,\n      mathNumber: string,\n      mathQuote: string,\n      originalString: string,\n    ): any => {\n      result.push(\n        mathQuote\n          ? originalString.replace(/\\\\(\\\\)?/g, '$1')\n          : mathNumber || match,\n      );\n    },\n  );\n\n  return result;\n};\n","import isObject from './isObject';\nimport isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types/form';\n\nexport default function set(object: FieldValues, path: string, value: any) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue: string | object = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types/form';\n\nexport default (data: FieldValues): any =>\n  Object.entries(data).reduce(\n    (previous: FieldValues, [key, value]): FieldValues => {\n      if (!isKey(key)) {\n        set(previous, key, value);\n        return previous;\n      }\n\n      return { ...previous, [key]: value };\n    },\n    {},\n  );\n","export default (val: unknown): val is undefined => val === undefined;\n","export default (value: any[]) => value.filter(Boolean);\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport unique from './unique';\n\nexport default (obj: any, path: string, defaultValue?: any) => {\n  const result = unique(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types/form';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          field.ref.focus();\n\n          break;\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types/form';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import isArray from '../utils/isArray';\nimport { RadioOrCheckboxOption } from '../types/form';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types/form';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types/form';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isArray from '../utils/isArray';\nimport isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types/form';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types/form';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  unmountFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value },\n      ref,\n    } = field;\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (unmountFieldsStateRef) {\n    return unmountFieldsStateRef.current[name];\n  }\n}\n","import { Ref } from '../types/form';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types/utils';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isArray from './isArray';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport isArray from '../utils/isArray';\nimport unset from '../utils/unset';\nimport unique from '../utils/unique';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types/form';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  unmountFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n    mutationWatcher,\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      unmountFieldsStateRef.current[name] = value;\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (isArray(options) && options.length) {\n      unique(options).forEach((option, index): void => {\n        const { ref, mutationWatcher } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n\n          if (mutationWatcher) {\n            mutationWatcher.disconnect();\n          }\n\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !unique(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    if (mutationWatcher) {\n      mutationWatcher.disconnect();\n    }\n\n    delete fieldsRef.current[name];\n  }\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import isObject from './isObject';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (!isObject(target) || !isObject(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    if (isObject(targetValue) && isObject(sourceValue)) {\n      target[key] = deepMerge(targetValue, sourceValue);\n    } else {\n      target[key] = sourceValue;\n    }\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport isArray from '../utils/isArray';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types/form';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  unmountFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n      );\n    }\n  }\n\n  return deepMerge(\n    transformToNestObject((unmountFieldsStateRef || {}).current || {}),\n    transformToNestObject(output),\n  );\n};\n","import isObject from './isObject';\nimport { FieldError } from '../types/form';\n\nexport default (\n  error: FieldError | undefined,\n  { type, types = {}, message }: FieldError,\n): boolean =>\n  isObject(error) &&\n  error.type === type &&\n  error.message === message &&\n  Object.keys(error.types || {}).length === Object.keys(types).length &&\n  Object.entries(error.types || {}).every(\n    ([key, value]) => types[key] === value,\n  );\n","import isEmptyObject from '../utils/isEmptyObject';\nimport isSameError from '../utils/isSameError';\nimport get from '../utils/get';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default function shouldRenderBasedOnError<\n  TFieldValues extends FieldValues\n>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FlatFieldErrors<TFieldValues>;\n  name: InternalFieldName<TFieldValues>;\n  validFields: Set<InternalFieldName<TFieldValues>>;\n  fieldsWithValidation: Set<InternalFieldName<TFieldValues>>;\n}): boolean {\n  const isFieldValid = isEmptyObject(error);\n  const isFormValid = isEmptyObject(errors);\n  const currentFieldError = get(error, name);\n  const existFieldError = get(errors, name);\n\n  if (isFieldValid && validFields.has(name)) {\n    return false;\n  }\n\n  if (\n    isFormValid !== isFieldValid ||\n    (!isFormValid && !existFieldError) ||\n    (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))\n  ) {\n    return true;\n  }\n\n  return currentFieldError && !isSameError(existFieldError, currentFieldError);\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types/form';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types/form';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types/form';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: FlatFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  FlatFieldErrors,\n} from '../types/form';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  unmountFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<FlatFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: FlatFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox\n          ? ((fields[name] as Field).options || [])[0].ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fieldsRef, name, unmountFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types/utils';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\nimport { FieldValues, InternalFieldName } from '../types/form';\n\nexport const getPath = <TFieldValues extends FieldValues = FieldValues>(\n  path: InternalFieldName<TFieldValues>,\n  values: TFieldValues | any[],\n): any[] => {\n  const getInnerPath = (\n    value: any,\n    key: number | string,\n    isObject?: boolean,\n  ) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values)\n    .map(([key, value]) => getInnerPath(value, key, isObject(values)))\n    .flat(Infinity);\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\nimport { DeepPartial } from '../types/utils';\nimport {\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types/form';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || isArray(value)) {\n      getPath<TFieldValues>(\n        fieldName,\n        value as TFieldValues,\n      ).forEach((name: string) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import isObject from '../utils/isObject';\nimport isArray from '../utils/isArray';\n\nexport default function deepEqual(object1: any = [], object2: any = []) {\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    const val1 = object1[key];\n    const val2 = object2[key];\n\n    if (\n      (isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2))\n        ? !deepEqual(val1, val2)\n        : val1 !== val2\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","export const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (names: Set<string>, name: string) =>\n  [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types/form';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import { Ref } from '../types/form';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove(\n  element: Ref,\n  onDetachCallback: () => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    if (isDetached(element)) {\n      observer.disconnect();\n      onDetachCallback();\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types/form';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types/form';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport shouldRenderBasedOnError from './logic/shouldRenderBasedOnError';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport deepEqual from './logic/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isArray from './utils/isArray';\nimport isString from './utils/isString';\nimport isSameError from './utils/isSameError';\nimport isUndefined from './utils/isUndefined';\nimport onDomRemove from './utils/onDomRemove';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport unique from './utils/unique';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  Touched,\n  FieldError,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  DefaultValuesAtRender,\n  FlatFieldErrors,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n  SubmitErrorHandler,\n} from './types/form';\nimport { LiteralToPrimitive, DeepPartial, NonUndefined } from './types/utils';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb =\n  typeof document !== UNDEFINED &&\n  !isWindowUndefined &&\n  !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as UnpackNestedValue<DeepPartial<TFieldValues>>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const errorsRef = React.useRef<FieldErrors<TFieldValues>>({});\n  const touchedFieldsRef = React.useRef<Touched<TFieldValues>>({});\n  const fieldArrayDefaultValues = React.useRef<Record<string, unknown[]>>({});\n  const dirtyFieldsRef = React.useRef<Touched<TFieldValues>>({});\n  const watchFieldsRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const watchFieldsHookRef = React.useRef<\n    Record<string, Set<InternalFieldName<TFieldValues>>>\n  >({});\n  const watchFieldsHookRenderRef = React.useRef<Record<string, Function>>({});\n  const fieldsWithValidationRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const validFieldsRef = React.useRef(\n    new Set<InternalFieldName<TFieldValues>>(),\n  );\n  const isValidRef = React.useRef(true);\n  const defaultValuesRef = React.useRef<\n    | FieldValue<UnpackNestedValue<TFieldValues>>\n    | UnpackNestedValue<DeepPartial<TFieldValues>>\n  >(defaultValues);\n  const defaultValuesAtRenderRef = React.useRef(\n    {} as DefaultValuesAtRender<TFieldValues>,\n  );\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const isSubmittedRef = React.useRef(false);\n  const isDirtyRef = React.useRef(false);\n  const submitCountRef = React.useRef(0);\n  const isSubmittingRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const unmountFieldsStateRef = React.useRef<Record<string, any>>({});\n  const resetFieldArrayFunctionRef = React.useRef<Record<string, () => void>>(\n    {},\n  );\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<Set<string>>(new Set());\n  const [, render] = React.useState();\n  const modeRef = React.useRef(modeChecker(mode));\n  const {\n    current: { isOnSubmit, isOnTouch },\n  } = modeRef;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    isSubmitted: isOnSubmit,\n    submitCount: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const {\n    current: { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange },\n  } = React.useRef(modeChecker(reValidateMode));\n  contextRef.current = context;\n  resolverRef.current = resolver;\n\n  const reRender = React.useCallback(\n    () => !isUnMount.current && render({}),\n    [],\n  );\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FlatFieldErrors<TFieldValues>,\n      shouldRender: boolean | null = false,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        shouldRenderBasedOnError<TFieldValues>({\n          errors: errorsRef.current,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(errorsRef.current, name);\n\n      if (isEmptyObject(error)) {\n        if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\n          validFieldsRef.current.add(name);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        errorsRef.current = unset(errorsRef.current, name);\n      } else {\n        validFieldsRef.current.delete(name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !isSameError(previousError, error[name] as FieldError);\n\n        set(errorsRef.current, name, error[name]);\n      }\n\n      if (shouldReRender && !isNullOrUndefined(shouldRender)) {\n        reRender();\n        return true;\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      { ref, options }: Field,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string).includes(selectRef.value)),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = String(\n                  value as string | boolean,\n                ).includes(checkboxRef.value)),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const setDirty = React.useCallback(\n    (name: InternalFieldName<TFieldValues>): boolean => {\n      const { isDirty, dirtyFields } = readFormStateRef.current;\n\n      if (!fieldsRef.current[name] || (!isDirty && !dirtyFields)) {\n        return false;\n      }\n\n      const isFieldDirty =\n        defaultValuesAtRenderRef.current[name] !==\n        getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n      const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\n      const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n      const previousIsDirty = isDirtyRef.current;\n\n      if (isFieldDirty) {\n        set(dirtyFieldsRef.current, name, true);\n      } else {\n        unset(dirtyFieldsRef.current, name);\n      }\n\n      isDirtyRef.current =\n        (isFieldArray &&\n          !deepEqual(\n            get(getValues(), getFieldArrayParentName(name)),\n            get(defaultValuesRef.current, getFieldArrayParentName(name)),\n          )) ||\n        !isEmptyObject(dirtyFieldsRef.current);\n\n      return (\n        (isDirty && previousIsDirty !== isDirtyRef.current) ||\n        (dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name))\n      );\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = await validateField<TFieldValues>(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          fieldsRef.current[name] as Field,\n          unmountFieldsStateRef,\n        );\n\n        shouldRenderBaseOnError(name, error, skipReRender ? null : false);\n\n        return isEmptyObject(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      payload:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues() as TFieldValues,\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (isArray(payload)) {\n        const isInputsValid = payload\n          .map((name) => {\n            const error = get(errors, name);\n\n            if (error) {\n              set(errorsRef.current, name, error);\n            } else {\n              unset(errorsRef.current, name);\n            }\n\n            return !error;\n          })\n          .every(Boolean);\n\n        reRender();\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, payload);\n\n        shouldRenderBaseOnError(\n          payload,\n          (error ? { [payload]: error } : {}) as FlatFieldErrors<TFieldValues>,\n          previousFormIsValid !== isValidRef.current,\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (isArray(fields)) {\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, true)),\n        );\n        reRender();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues>,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      getPath(name, value).forEach((fieldName) => {\n        const data = {};\n        const field = fieldsRef.current[fieldName];\n\n        if (field) {\n          set(data, name, value);\n          setFieldValue(field, get(data, fieldName));\n\n          if (shouldDirty) {\n            setDirty(fieldName);\n          }\n\n          if (shouldValidate) {\n            trigger(fieldName as FieldName<TFieldValues>);\n          }\n        }\n      });\n    },\n    [trigger, setFieldValue, setDirty],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig,\n    ): boolean | void => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(fieldsRef.current[name] as Field, value);\n        return config.shouldDirty && setDirty(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n      }\n\n      if (!shouldUnregister) {\n        unmountFieldsStateRef.current[name] = value;\n      }\n\n      return true;\n    },\n    [setDirty, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(watchFieldsHookRef.current)) {\n      for (const key in watchFieldsHookRef.current) {\n        if (\n          !name ||\n          watchFieldsHookRef.current[key].has(name) ||\n          watchFieldsHookRef.current[key].has(getFieldArrayParentName(name)) ||\n          !watchFieldsHookRef.current[key].size\n        ) {\n          watchFieldsHookRenderRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: NonUndefined<TFieldValue> extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config: SetValueConfig = {},\n  ): void {\n    const shouldRender =\n      setInternalValue(name, value as TFieldValues[string], config) ||\n      isFieldWatched(name);\n\n    renderWatchedInputs(name);\n\n    if (shouldRender) {\n      reRender();\n    }\n\n    if (config.shouldValidate) {\n      trigger(name as any);\n    }\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        const name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error: FlatFieldErrors<TFieldValues>;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isSubmitted: isSubmittedRef.current,\n            isTouched: !!get(touchedFieldsRef.current, name),\n            ...modeRef.current,\n          });\n          let shouldRender = setDirty(name) || isFieldWatched(name);\n\n          if (\n            isBlurEvent &&\n            !get(touchedFieldsRef.current, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(touchedFieldsRef.current, name, true);\n            shouldRender = true;\n          }\n\n          if (shouldSkipValidation) {\n            renderWatchedInputs(name);\n            return shouldRender && reRender();\n          }\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues() as TFieldValues,\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = isValidRef.current;\n            isValidRef.current = isEmptyObject(errors);\n\n            error = (get(errors, name)\n              ? { [name]: get(errors, name) }\n              : {}) as FlatFieldErrors<TFieldValues>;\n\n            if (previousFormIsValid !== isValidRef.current) {\n              shouldRender = true;\n            }\n          } else {\n            error = await validateField<TFieldValues>(\n              fieldsRef,\n              isValidateAllFieldCriteria,\n              field,\n              unmountFieldsStateRef,\n            );\n          }\n\n          renderWatchedInputs(name);\n\n          if (!shouldRenderBaseOnError(name, error) && shouldRender) {\n            reRender();\n          }\n        }\n      };\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, unmountFieldsStateRef);\n    }\n\n    if (isArray(payload)) {\n      return payload.reduce(\n        (previous, name) => ({\n          ...previous,\n          [name]: getFieldValue(fieldsRef, name, unmountFieldsStateRef),\n        }),\n        {},\n      );\n    }\n\n    return getFieldsValues(fieldsRef, unmountFieldsStateRef);\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const { errors } = await resolverRef.current!(\n        {\n          ...defaultValuesRef.current,\n          ...getValues(),\n          ...values,\n        },\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = isValidRef.current;\n      isValidRef.current = isEmptyObject(errors);\n\n      if (previousFormIsValid !== isValidRef.current) {\n        reRender();\n      }\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) =>\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        unmountFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      ),\n    [shouldUnregister],\n  );\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field: Field | undefined, forceDelete?: boolean) => {\n      if (\n        field &&\n        (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) ||\n          forceDelete)\n      ) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister) {\n          [\n            errorsRef,\n            touchedFieldsRef,\n            dirtyFieldsRef,\n            defaultValuesAtRenderRef,\n          ].forEach((data) => unset(data.current, field.ref.name));\n\n          [fieldsWithValidationRef, validFieldsRef].forEach((data) =>\n            data.current.delete(field.ref.name),\n          );\n\n          if (\n            readFormStateRef.current.isValid ||\n            readFormStateRef.current.touched ||\n            readFormStateRef.current.isDirty\n          ) {\n            isDirtyRef.current = !isEmptyObject(dirtyFieldsRef.current);\n            reRender();\n\n            if (resolverRef.current) {\n              validateResolver();\n            }\n          }\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    if (name) {\n      (isArray(name) ? name : [name]).forEach((inputName) =>\n        unset(errorsRef.current, inputName),\n      );\n    } else {\n      errorsRef.current = {};\n    }\n\n    reRender();\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption): void {\n    isValidRef.current = false;\n\n    set(errorsRef.current, name, {\n      ...error,\n      ref: (fieldsRef.current[name] || {})!.ref,\n    });\n\n    reRender();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? watchFieldsHookRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      const fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        unmountFieldsStateRef,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      if (isUndefined(watchId)) {\n        isWatchAllRef.current = true;\n      }\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    (isArray(name) ? name : [name]).forEach((fieldName) =>\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true),\n    );\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute:', ref);\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+]\\.\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          '📋 `name` prop should be in object shape: name=\"test[index].name\". https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let isFieldArray;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? isArray(field.options) &&\n          unique(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      const mutationWatcher = onDomRemove(ref, () =>\n        removeFieldEventListenerAndRef(field),\n      );\n\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...unique((field && field.options) || []),\n              {\n                ref,\n                mutationWatcher,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n            mutationWatcher,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(unmountFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : unmountFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n      isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(field, defaultValue);\n      }\n    }\n\n    if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\n      validateResolver();\n    } else if (!isEmptyObject(validateOptions)) {\n      fieldsWithValidationRef.current.add(name);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          unmountFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = isValidRef.current;\n\n          isEmptyObject(error)\n            ? validFieldsRef.current.add(name)\n            : (isValidRef.current = false);\n\n          if (previousFormIsValid !== isValidRef.current) {\n            reRender();\n          }\n        });\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      const fieldValue = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\n      defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue\n        ? isObject(fieldValue)\n          ? { ...fieldValue }\n          : fieldValue\n        : defaultValue;\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues: FieldValues = getFieldsValues(\n        fieldsRef,\n        unmountFieldsStateRef,\n      );\n\n      if (readFormStateRef.current.isSubmitting) {\n        isSubmittingRef.current = true;\n        reRender();\n      }\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues as TFieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          errorsRef.current = errors;\n          fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                unmountFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                validFieldsRef.current.delete(name);\n              } else if (fieldsWithValidationRef.current.has(name)) {\n                unset(errorsRef.current, name);\n                validFieldsRef.current.add(name);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(errorsRef.current).every((name) =>\n            Object.keys(fieldsRef.current).includes(name),\n          )\n        ) {\n          errorsRef.current = {};\n          reRender();\n          await onValid(\n            fieldValues as UnpackNestedValue<TSubmitFieldValues>,\n            e,\n          );\n        } else {\n          errorsRef.current = {\n            ...errorsRef.current,\n            ...fieldErrors,\n          };\n          if (onInvalid) {\n            await onInvalid(fieldErrors, e);\n          }\n          if (shouldFocusError) {\n            focusOnErrorField(fieldsRef.current, fieldErrors);\n          }\n        }\n      } finally {\n        isSubmittedRef.current = true;\n        isSubmittingRef.current = false;\n        submitCountRef.current = submitCountRef.current + 1;\n        reRender();\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!errors) {\n      errorsRef.current = {};\n    }\n\n    if (!touched) {\n      touchedFieldsRef.current = {};\n    }\n\n    if (!isValid) {\n      validFieldsRef.current = new Set();\n      fieldsWithValidationRef.current = new Set();\n      isValidRef.current = true;\n    }\n\n    if (!isDirty) {\n      isDirtyRef.current = false;\n    }\n\n    if (!dirtyFields) {\n      dirtyFieldsRef.current = {};\n    }\n\n    if (!isSubmitted) {\n      isSubmittedRef.current = false;\n    }\n\n    if (!submitCount) {\n      submitCountRef.current = 0;\n    }\n\n    defaultValuesAtRenderRef.current = {} as DefaultValuesAtRender<\n      TFieldValues\n    >;\n    fieldArrayDefaultValues.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n\n    defaultValuesRef.current = values || { ...defaultValuesRef.current };\n\n    if (values) {\n      renderWatchedInputs('');\n    }\n\n    unmountFieldsStateRef.current = shouldUnregister ? {} : values || {};\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    resetRefs(omitResetState);\n\n    reRender();\n  };\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n\n    return () => {\n      isUnMount.current = true;\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      fieldsRef.current &&\n        Object.values(fieldsRef.current).forEach((field) =>\n          removeFieldEventListenerAndRef(field, true),\n        );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    isValidRef.current =\n      validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\n      isEmptyObject(errorsRef.current);\n  }\n\n  const formState = {\n    dirtyFields: dirtyFieldsRef.current,\n    isSubmitted: isSubmittedRef.current,\n    submitCount: submitCountRef.current,\n    touched: touchedFieldsRef.current,\n    isDirty: isDirtyRef.current,\n    isSubmitting: isSubmittingRef.current,\n    isValid: isOnSubmit\n      ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\n      : isValidRef.current,\n  };\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [\n      reRender,\n      setInternalValue,\n      trigger,\n    ]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n    formState: isProxyEnabled\n      ? new Proxy<FormStateProxy<TFieldValues>>(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (\n              process.env.NODE_ENV !== 'production' &&\n              prop === 'isValid' &&\n              isOnSubmit\n            ) {\n              console.warn(\n                '📋 `formState.isValid` is applicable with `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n              );\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n  };\n\n  const control = {\n    removeFieldEventListener,\n    renderWatchedInputs,\n    watchInternal,\n    reRender,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange,\n    },\n    errorsRef,\n    touchedFieldsRef,\n    fieldsRef,\n    isWatchAllRef,\n    watchFieldsRef,\n    resetFieldArrayFunctionRef,\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    fieldArrayDefaultValues,\n    validFieldsRef,\n    dirtyFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    isDirtyRef,\n    isSubmittedRef,\n    readFormStateRef,\n    defaultValuesRef,\n    unmountFieldsStateRef,\n    validateResolver: resolver ? validateResolver : undefined,\n    ...commonProps,\n  };\n\n  return {\n    watch,\n    control,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: errorsRef.current,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues } from './types/form';\nimport { FormProviderProps } from './types/props';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\nimport unique from './unique';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return unique(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isUndefined from './isUndefined';\nimport isArray from './isArray';\n\nexport default <T>(data: T[], from: number, to: number): (T | undefined)[] => {\n  if (isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined as any;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","import isArray from './isArray';\n\nexport default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(isArray(value) ? value : [value || undefined]), ...data];\n}\n","import isArray from './isArray';\n\nexport default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","import isArray from './isArray';\n\nexport default <T>(value: T | T[]): undefined[] | undefined =>\n  isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isArray from './isArray';\nimport isObject from './isObject';\n\nfunction mapValueToBoolean(value: any) {\n  if (isObject(value)) {\n    const object: any = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport const filterBooleanArray = <T>(value: T): T[] =>\n  isArray(value)\n    ? value.map(mapValueToBoolean).flat()\n    : mapValueToBoolean(value);\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport isObject from './utils/isObject';\nimport deepEqual from './logic/deepEqual';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport isUndefined from './utils/isUndefined';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport isArray from './utils/isArray';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport { filterBooleanArray } from './utils/filterBooleanArray';\nimport unique from './utils/unique';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n} from './types/form';\n\nconst appendId = <TValue extends object, TKeyName extends string>(\n  value: TValue,\n  keyName: TKeyName,\n): Partial<ArrayField<TValue, TKeyName>> => ({\n  [keyName]: generateId(),\n  ...(isObject(value) ? value : { value }),\n});\n\nconst mapIds = <TData extends object, TKeyName extends string>(\n  data: TData | TData[],\n  keyName: TKeyName,\n) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop.');\n    }\n\n    if (!name) {\n      console.warn('📋 useFieldArray is missing `name` attribute.');\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const {\n    isWatchAllRef,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    reRender,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    errorsRef,\n    dirtyFieldsRef,\n    isDirtyRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    watchFieldsRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValues,\n    validateResolver,\n    renderWatchedInputs,\n    getValues,\n  } = control || methods.control;\n  let shouldRender;\n\n  const getDefaultValues = () => [\n    ...(get(fieldArrayDefaultValues.current, name) ||\n      get(defaultValuesRef.current, name) ||\n      []),\n  ];\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>(\n    getDefaultValues(),\n  );\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  const allFields = React.useRef<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(fields);\n  const rootParentName = getFieldArrayParentName(name);\n\n  const getCurrentFieldsValues = () =>\n    get(getValues() || {}, name, allFields.current).map(\n      (item: Partial<TFieldArrayValues>, index: number) => ({\n        ...allFields.current[index],\n        ...item,\n      }),\n    );\n\n  allFields.current = fields;\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValues.current, name) && rootParentName) {\n    set(\n      fieldArrayDefaultValues.current,\n      rootParentName,\n      get(defaultValuesRef.current, rootParentName),\n    );\n  }\n\n  const appendValueWithKey = (values: Partial<TFieldArrayValues>[]) =>\n    values.map((value: Partial<TFieldArrayValues>) => appendId(value, keyName));\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = {};\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const shouldRenderFieldArray = (shouldRender?: boolean) => {\n    renderWatchedInputs(name);\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.isValid) &&\n      !isWatchAllRef.current\n    ) {\n      shouldRender = true;\n    }\n\n    shouldRender && reRender();\n  };\n\n  const resetFields = (\n    flagOrFields?: (Partial<TFieldArrayValues> | undefined)[],\n  ) => {\n    if (\n      readFormStateRef.current.isDirty ||\n      readFormStateRef.current.dirtyFields\n    ) {\n      isDirtyRef.current =\n        isUndefined(flagOrFields) ||\n        !deepEqual(\n          flagOrFields.map(({ [keyName]: omitted, ...rest } = {}) => rest),\n          get(defaultValuesRef.current, name, []),\n        );\n    }\n\n    for (const key in fieldsRef.current) {\n      if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n      }\n    }\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    shouldRender = false;\n    setFieldAndValidState([\n      ...allFields.current,\n      ...(isArray(value)\n        ? appendValueWithKey(value)\n        : [appendId(value, keyName)]),\n    ]);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(dirtyFieldsRef.current, name, [\n        ...(get(dirtyFieldsRef.current, name) ||\n          fillEmptyArray(fields.slice(0, 1))),\n        ...filterBooleanArray(value),\n      ]);\n      isDirtyRef.current = true;\n      shouldRender = true;\n    }\n\n    focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    shouldRender = false;\n\n    setFieldAndValidState(\n      prependAt(\n        getCurrentFieldsValues(),\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields();\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(\n        errorsRef.current,\n        name,\n        prependAt(get(errorsRef.current, name), emptyArray),\n      );\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(touchedFieldsRef.current, name)\n    ) {\n      set(\n        touchedFieldsRef.current,\n        name,\n        prependAt(get(touchedFieldsRef.current, name), emptyArray),\n      );\n      shouldRender = true;\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      set(\n        dirtyFieldsRef.current,\n        name,\n        prependAt(\n          get(dirtyFieldsRef.current, name) || [],\n          filterBooleanArray(value),\n        ),\n      );\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    shouldRender = false;\n\n    const fieldValues = getCurrentFieldsValues();\n    setFieldAndValidState(removeArrayAt(fieldValues, index));\n    resetFields(removeArrayAt(fieldValues, index));\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(\n        errorsRef.current,\n        name,\n        removeArrayAt(get(errorsRef.current, name), index),\n      );\n\n      if (!unique(get(errorsRef.current, name, [])).length) {\n        unset(errorsRef.current, name);\n      }\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(touchedFieldsRef.current, name)\n    ) {\n      set(\n        touchedFieldsRef.current,\n        name,\n        removeArrayAt(get(touchedFieldsRef.current, name), index),\n      );\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      get(dirtyFieldsRef.current, name)\n    ) {\n      set(\n        dirtyFieldsRef.current,\n        name,\n        removeArrayAt(get(dirtyFieldsRef.current, name), index),\n      );\n\n      if (!unique(get(dirtyFieldsRef.current, name, [])).length) {\n        unset(dirtyFieldsRef.current, name);\n      }\n\n      shouldRender = true;\n    }\n\n    if (readFormStateRef.current.isValid && !validateResolver) {\n      let fieldIndex = -1;\n      let isFound = false;\n      const isIndexUndefined = isUndefined(index);\n\n      while (fieldIndex++ < fields.length) {\n        const isLast = fieldIndex === fields.length - 1;\n        const isCurrentIndex =\n          (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\n\n        if (isCurrentIndex || isIndexUndefined) {\n          isFound = true;\n        }\n\n        if (!isFound) {\n          continue;\n        }\n\n        for (const key in fields[fieldIndex]) {\n          const getFieldName = (index = 0) =>\n            `${name}[${fieldIndex - index}].${key}`;\n\n          if (isCurrentIndex || isLast || isIndexUndefined) {\n            validFieldsRef.current.delete(getFieldName());\n            fieldsWithValidationRef.current.delete(getFieldName());\n          } else {\n            if (validFieldsRef.current.has(getFieldName())) {\n              validFieldsRef.current.add(getFieldName(1));\n            }\n            if (fieldsWithValidationRef.current.has(getFieldName())) {\n              fieldsWithValidationRef.current.add(getFieldName(1));\n            }\n          }\n        }\n      }\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    shouldRender = false;\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n\n    setFieldAndValidState(\n      insertAt(\n        fieldValues,\n        index,\n        isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)],\n      ),\n    );\n    resetFields(insertAt(fieldValues, index));\n\n    if (isArray(get(errorsRef.current, name))) {\n      set(\n        errorsRef.current,\n        name,\n        insertAt(get(errorsRef.current, name), index, emptyArray),\n      );\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(touchedFieldsRef.current, name)\n    ) {\n      set(\n        touchedFieldsRef.current,\n        name,\n        insertAt(get(touchedFieldsRef.current, name), index, emptyArray),\n      );\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      get(dirtyFieldsRef.current, name)\n    ) {\n      set(\n        dirtyFieldsRef.current,\n        name,\n        insertAt(\n          get(dirtyFieldsRef.current, name),\n          index,\n          filterBooleanArray(value),\n        ),\n      );\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    shouldRender = false;\n\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields(fieldValues);\n    setFieldAndValidState([...fieldValues]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      swapArrayAt(get(errorsRef.current, name), indexA, indexB);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(touchedFieldsRef.current, name)\n    ) {\n      swapArrayAt(get(touchedFieldsRef.current, name), indexA, indexB);\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      get(dirtyFieldsRef.current, name)\n    ) {\n      swapArrayAt(get(dirtyFieldsRef.current, name), indexA, indexB);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const move = (from: number, to: number) => {\n    shouldRender = false;\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields(fieldValues);\n    setFieldAndValidState([...fieldValues]);\n\n    if (isArray(get(errorsRef.current, name))) {\n      moveArrayAt(get(errorsRef.current, name), from, to);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(touchedFieldsRef.current, name)\n    ) {\n      moveArrayAt(get(touchedFieldsRef.current, name), from, to);\n      shouldRender = true;\n    }\n\n    if (\n      (readFormStateRef.current.dirtyFields ||\n        readFormStateRef.current.isDirty) &&\n      get(dirtyFieldsRef.current, name)\n    ) {\n      moveArrayAt(get(dirtyFieldsRef.current, name), from, to);\n      shouldRender = true;\n    }\n\n    shouldRenderFieldArray(shouldRender);\n  };\n\n  const reset = () => {\n    resetFields();\n    memoizedDefaultValues.current = getDefaultValues();\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    const defaultValues = get(fieldArrayDefaultValues.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValues.current, name, defaultValues);\n    }\n\n    if (isWatchAllRef.current) {\n      reRender();\n    } else if (watchFieldsRef) {\n      let shouldRenderUseWatch = true;\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          reRender();\n          shouldRenderUseWatch = false;\n          break;\n        }\n      }\n\n      shouldRenderUseWatch && renderWatchedInputs(name);\n    }\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [\n    fields,\n    name,\n    fieldArrayDefaultValues,\n    reRender,\n    fieldsRef,\n    watchFieldsRef,\n    isWatchAllRef,\n  ]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    resetFunctions[name] = reset;\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      fieldArrayNamesRef.current.delete(name);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [fields, name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isArray from './utils/isArray';\nimport {\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types/form';\nimport { DeepPartial } from './types/utils';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop.');\n    }\n\n    if (name === '') {\n      console.warn('📋 useWatch is missing `name` attribute.');\n    }\n  }\n\n  const {\n    watchFieldsHookRef,\n    watchFieldsHookRenderRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  const updateWatchValue = React.useCallback(\n    () => setValue(watchInternal(name, defaultValueRef.current, idRef.current)),\n    [setValue, watchInternal, defaultValueRef, name, idRef],\n  );\n\n  React.useEffect(() => {\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = watchFieldsHookRenderRef.current;\n    const watchFieldsHook = watchFieldsHookRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    updateWatchValue,\n    watchFieldsHookRenderRef,\n    watchFieldsHookRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types/form';\nimport { ControllerProps } from './types/props';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production' && !control && !methods) {\n    throw new Error('📋 Controller is missing `control` prop.');\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    isSubmittedRef,\n    touchedFieldsRef,\n    readFormStateRef,\n    reRender,\n    fieldsRef,\n    fieldArrayNamesRef,\n    unmountFieldsStateRef,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(unmountFieldsStateRef.current, name)) && isNotFieldArray\n      ? unmountFieldsStateRef.current[name]\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const onFocusRef = React.useRef(onFocus);\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (isUndefined(value)) {\n      console.warn(\n        '📋 Controller `defaultValue` or useForm `defaultValues` is missing.',\n      );\n    }\n\n    if (as && render) {\n      console.warn('📋 Should use either `as` or `render` prop.');\n    }\n\n    if (!isNotFieldArray && isUndefined(defaultValue)) {\n      console.warn(\n        '📋 Controller is missing `defaultValue` prop when using `useFieldArray`.',\n      );\n    }\n  }\n\n  const shouldValidate = (isBlurEvent?: boolean) =>\n    !skipValidation({\n      isBlurEvent,\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted: isSubmittedRef.current,\n      ...mode,\n    });\n\n  const commonTask = ([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  };\n\n  const registerField = React.useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn('📋 Field is missing `name` prop.');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\n          set(data) {\n            setInputStateValue(data);\n            valueRef.current = data;\n          },\n          get() {\n            return valueRef.current;\n          },\n        }),\n        rules,\n      );\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [fieldsRef, rules, name, onFocusRef, register]);\n\n  React.useEffect(\n    () => () => {\n      !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\n    },\n    [unregister, name, fieldArrayNamesRef],\n  );\n\n  React.useEffect(() => {\n    registerField();\n  }, [registerField]);\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = () => {\n    if (\n      readFormStateRef.current.touched &&\n      !get(touchedFieldsRef.current, name)\n    ) {\n      set(touchedFieldsRef.current, name, true);\n      reRender();\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  };\n\n  const onChange = (...event: any[]) =>\n    setValue(name, commonTask(event), {\n      shouldValidate: shouldValidate(),\n      shouldDirty: true,\n    });\n\n  const props = {\n    ...rest,\n    onChange,\n    onBlur,\n    name,\n    value,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props)\n    : render\n    ? render({\n        onChange,\n        onBlur,\n        value,\n        name,\n      })\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}