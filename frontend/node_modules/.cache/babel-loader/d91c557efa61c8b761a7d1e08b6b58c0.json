{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, canUseWeakMap } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, isFieldValueToBeMerged, storeValueIsStoreObject } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport var defaultDataIdFromObject = function (_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (id === void 0) id = _id;\n\n    if (id !== void 0) {\n      return __typename + \":\" + (typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n};\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.storageTrie = new KeyTrie(true);\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n\n    if (typename) {\n      var rootId = this.rootIdsByTypename[typename];\n      if (\"string\" === typeof rootId) return [rootId];\n    }\n\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap\n    };\n    var id;\n    var policy = this.getTypePolicy(typename, false);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var existing = _this.getTypePolicy(typename, true);\n\n      var incoming = typePolicies[typename];\n      var keyFields = incoming.keyFields,\n          fields = incoming.fields;\n      if (incoming.queryType) _this.setRootTypename(\"Query\", typename);\n      if (incoming.mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (incoming.subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n      existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n      if (fields) {\n        Object.keys(fields).forEach(function (fieldName) {\n          var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n          var incoming = fields[fieldName];\n\n          if (typeof incoming === \"function\") {\n            existing.read = incoming;\n          } else {\n            var keyArgs = incoming.keyArgs,\n                read = incoming.read,\n                merge = incoming.merge;\n            existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n            if (typeof read === \"function\") existing.read = read;\n            existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n          }\n\n          if (existing.read && existing.merge) {\n            existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    });\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 1) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      var subtypeSet = _this.getSubtypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n    if (typename) {\n      return this.typePolicies[typename] || createIfMissing && (this.typePolicies[typename] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n    var policy = this.getTypePolicy(supertype, createIfMissing);\n\n    if (policy) {\n      return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n    }\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    var typePolicy = this.getTypePolicy(typename, createIfMissing);\n\n    if (typePolicy) {\n      var fieldPolicies = typePolicy.fields || createIfMissing && (typePolicy.fields = Object.create(null));\n\n      if (fieldPolicies) {\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n      }\n    }\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes) {\n      var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var subtypes = workQueue_1[i];\n\n        if (subtypes) {\n          if (subtypes.has(typename)) return true;\n          subtypes.forEach(function (subtype) {\n            var subsubtypes = _this.getSubtypeSet(subtype, false);\n\n            if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n              workQueue_1.push(subsubtypes);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, this.storageTrie.lookup(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.merge);\n  };\n\n  Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n    var _this = this;\n\n    if (isFieldValueToBeMerged(incoming)) {\n      var field = incoming.__field;\n      var fieldName = field.name.value;\n      var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n      var storage = storageKeys ? this.storageTrie.lookupArray(storageKeys) : null;\n      incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, {\n        typename: incoming.__typename,\n        fieldName: fieldName,\n        field: field,\n        variables: context.variables\n      }, context, storage));\n    }\n\n    if (Array.isArray(incoming)) {\n      return incoming.map(function (item) {\n        return _this.applyMerges(void 0, item, context);\n      });\n    }\n\n    if (storeValueIsStoreObject(incoming)) {\n      var e_1 = existing;\n      var i_1 = incoming;\n      var firstStorageKey_1 = isReference(e_1) ? e_1.__ref : typeof e_1 === \"object\" && e_1;\n      var newFields_1;\n      Object.keys(i_1).forEach(function (storeFieldName) {\n        var incomingValue = i_1[storeFieldName];\n\n        var appliedValue = _this.applyMerges(context.store.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n\n        if (appliedValue !== incomingValue) {\n          newFields_1 = newFields_1 || Object.create(null);\n          newFields_1[storeFieldName] = appliedValue;\n        }\n      });\n\n      if (newFields_1) {\n        return __assign(__assign({}, i_1), newFields_1);\n      }\n    }\n\n    return incoming;\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      getFieldValue = _a.getFieldValue,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function (fieldNameOrOptions, from) {\n      var options = typeof fieldNameOrOptions === \"string\" ? {\n        fieldName: fieldNameOrOptions,\n        from: from\n      } : __assign({}, fieldNameOrOptions);\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField(options, context);\n    },\n    mergeObjects: function (existing, incoming) {\n      if (Array.isArray(existing) || Array.isArray(incoming)) {\n        throw process.env.NODE_ENV === \"production\" ? new InvariantError(2) : new InvariantError(\"Cannot automatically merge arrays\");\n      }\n\n      if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n        var eType = getFieldValue(existing, \"__typename\");\n        var iType = getFieldValue(incoming, \"__typename\");\n        var typesDiffer = eType && iType && eType !== iType;\n        var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n\n        if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(applied)) {\n          return applied;\n        }\n\n        return __assign(__assign({}, existing), applied);\n      }\n\n      return incoming;\n    }\n  };\n}\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n      process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 3) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n      keyObj[prevKey = s] = response[responseName];\n    }\n  });\n  return keyObj;\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/policies.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, canUseWeakMap, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, isFieldValueToBeMerged, storeValueIsStoreObject, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nexport var defaultDataIdFromObject = function (_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                id !== void 0 ? { id: id } :\n                    _id !== void 0 ? { _id: _id } :\n                        void 0;\n        }\n        if (id === void 0)\n            id = _id;\n        if (id !== void 0) {\n            return __typename + \":\" + ((typeof id === \"number\" ||\n                typeof id === \"string\") ? id : JSON.stringify(id));\n        }\n    }\n};\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.storageTrie = new KeyTrie(true);\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n        var typename = selectionSet && fragmentMap\n            ? getTypenameFromResult(object, selectionSet, fragmentMap)\n            : object.__typename;\n        if (typename) {\n            var rootId = this.rootIdsByTypename[typename];\n            if (\"string\" === typeof rootId)\n                return [rootId];\n        }\n        var context = {\n            typename: typename,\n            selectionSet: selectionSet,\n            fragmentMap: fragmentMap,\n        };\n        var id;\n        var policy = this.getTypePolicy(typename, false);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (Array.isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id && String(id);\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var existing = _this.getTypePolicy(typename, true);\n            var incoming = typePolicies[typename];\n            var keyFields = incoming.keyFields, fields = incoming.fields;\n            if (incoming.queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (incoming.mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (incoming.subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            existing.keyFn =\n                keyFields === false ? nullKeyFieldsFn :\n                    Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                        typeof keyFields === \"function\" ? keyFields :\n                            existing.keyFn;\n            if (fields) {\n                Object.keys(fields).forEach(function (fieldName) {\n                    var existing = _this.getFieldPolicy(typename, fieldName, true);\n                    var incoming = fields[fieldName];\n                    if (typeof incoming === \"function\") {\n                        existing.read = incoming;\n                    }\n                    else {\n                        var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                        existing.keyFn =\n                            keyArgs === false ? simpleKeyArgsFn :\n                                Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                    typeof keyArgs === \"function\" ? keyArgs :\n                                        existing.keyFn;\n                        if (typeof read === \"function\")\n                            existing.read = read;\n                        existing.merge =\n                            typeof merge === \"function\" ? merge :\n                                merge === true ? mergeTrueFn :\n                                    merge === false ? mergeFalseFn :\n                                        existing.merge;\n                    }\n                    if (existing.read && existing.merge) {\n                        existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                    }\n                });\n            }\n        });\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 1) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n            if (old)\n                delete this.rootIdsByTypename[old];\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            var subtypeSet = _this.getSubtypeSet(supertype, true);\n            possibleTypes[supertype].forEach(subtypeSet.add, subtypeSet);\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename, createIfMissing) {\n        if (typename) {\n            return this.typePolicies[typename] || (createIfMissing && (this.typePolicies[typename] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSubtypeSet = function (supertype, createIfMissing) {\n        var policy = this.getTypePolicy(supertype, createIfMissing);\n        if (policy) {\n            return policy.subtypes || (createIfMissing ? policy.subtypes = new Set() : void 0);\n        }\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        var typePolicy = this.getTypePolicy(typename, createIfMissing);\n        if (typePolicy) {\n            var fieldPolicies = typePolicy.fields || (createIfMissing && (typePolicy.fields = Object.create(null)));\n            if (fieldPolicies) {\n                return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n            }\n        }\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes) {\n            var workQueue_1 = [this.getSubtypeSet(supertype, false)];\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var subtypes = workQueue_1[i];\n                if (subtypes) {\n                    if (subtypes.has(typename))\n                        return true;\n                    subtypes.forEach(function (subtype) {\n                        var subsubtypes = _this.getSubtypeSet(subtype, false);\n                        if (subsubtypes && workQueue_1.indexOf(subsubtypes) < 0) {\n                            workQueue_1.push(subsubtypes);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (Array.isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, this.storageTrie.lookup(isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n        }\n        return existing;\n    };\n    Policies.prototype.hasMergeFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.merge);\n    };\n    Policies.prototype.applyMerges = function (existing, incoming, context, storageKeys) {\n        var _this = this;\n        if (isFieldValueToBeMerged(incoming)) {\n            var field = incoming.__field;\n            var fieldName = field.name.value;\n            var merge = this.getFieldPolicy(incoming.__typename, fieldName, false).merge;\n            var storage = storageKeys\n                ? this.storageTrie.lookupArray(storageKeys)\n                : null;\n            incoming = merge(existing, incoming.__value, makeFieldFunctionOptions(this, void 0, { typename: incoming.__typename, fieldName: fieldName,\n                field: field, variables: context.variables }, context, storage));\n        }\n        if (Array.isArray(incoming)) {\n            return incoming.map(function (item) { return _this.applyMerges(void 0, item, context); });\n        }\n        if (storeValueIsStoreObject(incoming)) {\n            var e_1 = existing;\n            var i_1 = incoming;\n            var firstStorageKey_1 = isReference(e_1)\n                ? e_1.__ref\n                : typeof e_1 === \"object\" && e_1;\n            var newFields_1;\n            Object.keys(i_1).forEach(function (storeFieldName) {\n                var incomingValue = i_1[storeFieldName];\n                var appliedValue = _this.applyMerges(context.store.getFieldValue(e_1, storeFieldName), incomingValue, context, firstStorageKey_1 ? [firstStorageKey_1, storeFieldName] : void 0);\n                if (appliedValue !== incomingValue) {\n                    newFields_1 = newFields_1 || Object.create(null);\n                    newFields_1[storeFieldName] = appliedValue;\n                }\n            });\n            if (newFields_1) {\n                return __assign(__assign({}, i_1), newFields_1);\n            }\n        }\n        return incoming;\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, getFieldValue = _a.getFieldValue, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function (fieldNameOrOptions, from) {\n            var options = typeof fieldNameOrOptions === \"string\" ? {\n                fieldName: fieldNameOrOptions,\n                from: from,\n            } : __assign({}, fieldNameOrOptions);\n            if (void 0 === options.from) {\n                options.from = objectOrReference;\n            }\n            if (void 0 === options.variables) {\n                options.variables = variables;\n            }\n            return policies.readField(options, context);\n        },\n        mergeObjects: function (existing, incoming) {\n            if (Array.isArray(existing) || Array.isArray(incoming)) {\n                throw process.env.NODE_ENV === \"production\" ? new InvariantError(2) : new InvariantError(\"Cannot automatically merge arrays\");\n            }\n            if (existing && typeof existing === \"object\" &&\n                incoming && typeof incoming === \"object\") {\n                var eType = getFieldValue(existing, \"__typename\");\n                var iType = getFieldValue(incoming, \"__typename\");\n                var typesDiffer = eType && iType && eType !== iType;\n                var applied = policies.applyMerges(typesDiffer ? void 0 : existing, incoming, context);\n                if (typesDiffer ||\n                    !storeValueIsStoreObject(existing) ||\n                    !storeValueIsStoreObject(applied)) {\n                    return applied;\n                }\n                return __assign(__assign({}, existing), applied);\n            }\n            return incoming;\n        }\n    };\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n    return function (args, context) {\n        return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier)) : context.fieldName;\n    };\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var trie = new KeyTrie(canUseWeakMap);\n    return function (object, context) {\n        var aliasMap;\n        if (context.selectionSet && context.fragmentMap) {\n            var info = trie.lookupArray([\n                context.selectionSet,\n                context.fragmentMap,\n            ]);\n            aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n        }\n        var keyObject = context.keyObject =\n            computeKeyObject(object, specifier, aliasMap);\n        return context.typename + \":\" + JSON.stringify(keyObject);\n    };\n}\nfunction makeAliasMap(selectionSet, fragmentMap) {\n    var map = Object.create(null);\n    var workQueue = new Set([selectionSet]);\n    workQueue.forEach(function (selectionSet) {\n        selectionSet.selections.forEach(function (selection) {\n            if (isField(selection)) {\n                if (selection.alias) {\n                    var responseKey = selection.alias.value;\n                    var storeKey = selection.name.value;\n                    if (storeKey !== responseKey) {\n                        var aliases = map.aliases || (map.aliases = Object.create(null));\n                        aliases[storeKey] = responseKey;\n                    }\n                }\n                if (selection.selectionSet) {\n                    var subsets = map.subsets || (map.subsets = Object.create(null));\n                    subsets[selection.name.value] =\n                        makeAliasMap(selection.selectionSet, fragmentMap);\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, fragmentMap);\n                if (fragment) {\n                    workQueue.add(fragment.selectionSet);\n                }\n            }\n        });\n    });\n    return map;\n}\nfunction computeKeyObject(response, specifier, aliasMap) {\n    var keyObj = Object.create(null);\n    var prevKey;\n    specifier.forEach(function (s) {\n        if (Array.isArray(s)) {\n            if (typeof prevKey === \"string\") {\n                var subsets = aliasMap && aliasMap.subsets;\n                var subset = subsets && subsets[prevKey];\n                keyObj[prevKey] = computeKeyObject(response[prevKey], s, subset);\n            }\n        }\n        else {\n            var aliases = aliasMap && aliasMap.aliases;\n            var responseName = aliases && aliases[s] || s;\n            process.env.NODE_ENV === \"production\" ? invariant(hasOwn.call(response, responseName), 3) : invariant(hasOwn.call(response, responseName), \"Missing field '\" + responseName + \"' while computing key fields\");\n            keyObj[prevKey = s] = response[responseName];\n        }\n    });\n    return keyObj;\n}\n//# sourceMappingURL=policies.js.map"]},"metadata":{},"sourceType":"module"}