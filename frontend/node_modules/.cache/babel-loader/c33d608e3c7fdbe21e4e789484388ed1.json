{"ast":null,"code":"import { __assign, __spreadArrays } from \"tslib\";\nexport function concatPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming) {\n      return existing ? __spreadArrays(existing, incoming) : incoming;\n    }\n  };\n}\nexport function offsetLimitPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming, _a) {\n      var args = _a.args;\n      var merged = existing ? existing.slice(0) : [];\n      var start = args ? args.offset : merged.length;\n      var end = start + incoming.length;\n\n      for (var i = start; i < end; ++i) {\n        merged[i] = incoming[i - start];\n      }\n\n      return merged;\n    }\n  };\n}\nexport function relayStylePagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    read: function (existing, _a) {\n      var canRead = _a.canRead;\n      if (!existing) return;\n      var edges = existing.edges.filter(function (edge) {\n        return canRead(edge.node);\n      });\n      return __assign(__assign({}, existing), {\n        edges: edges,\n        pageInfo: __assign(__assign({}, existing.pageInfo), {\n          startCursor: cursorFromEdge(edges, 0),\n          endCursor: cursorFromEdge(edges, -1)\n        })\n      });\n    },\n    merge: function (existing, incoming, _a) {\n      if (existing === void 0) {\n        existing = makeEmptyData();\n      }\n\n      var args = _a.args;\n      if (!args) return existing;\n      var incomingEdges = incoming.edges.slice(0);\n\n      if (incoming.pageInfo) {\n        updateCursor(incomingEdges, 0, incoming.pageInfo.startCursor);\n        updateCursor(incomingEdges, -1, incoming.pageInfo.endCursor);\n      }\n\n      var prefix = existing.edges;\n      var suffix = [];\n\n      if (args.after) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.after;\n        });\n\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n        }\n      } else if (args.before) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.before;\n        });\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else {\n        prefix = [];\n      }\n\n      var edges = __spreadArrays(prefix, incomingEdges, suffix);\n\n      var pageInfo = __assign(__assign(__assign({}, incoming.pageInfo), existing.pageInfo), {\n        startCursor: cursorFromEdge(edges, 0),\n        endCursor: cursorFromEdge(edges, -1)\n      });\n\n      var updatePageInfo = function (name) {\n        var value = incoming.pageInfo[name];\n\n        if (value !== void 0) {\n          pageInfo[name] = value;\n        }\n      };\n\n      if (!prefix.length) updatePageInfo(\"hasPreviousPage\");\n      if (!suffix.length) updatePageInfo(\"hasNextPage\");\n      return __assign(__assign(__assign({}, existing), incoming), {\n        edges: edges,\n        pageInfo: pageInfo\n      });\n    }\n  };\n}\n\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}\n\nfunction cursorFromEdge(edges, index) {\n  if (index < 0) index += edges.length;\n  var edge = edges[index];\n  return edge && edge.cursor || \"\";\n}\n\nfunction updateCursor(edges, index, cursor) {\n  if (index < 0) index += edges.length;\n  var edge = edges[index];\n\n  if (cursor && cursor !== edge.cursor) {\n    edges[index] = __assign(__assign({}, edge), {\n      cursor: cursor\n    });\n  }\n}","map":{"version":3,"sources":["../../../src/utilities/policies/pagination.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign, __spreadArrays } from \"tslib\";\nexport function concatPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming) {\n            return existing ? __spreadArrays(existing, incoming) : incoming;\n        },\n    };\n}\nexport function offsetLimitPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming, _a) {\n            var args = _a.args;\n            var merged = existing ? existing.slice(0) : [];\n            var start = args ? args.offset : merged.length;\n            var end = start + incoming.length;\n            for (var i = start; i < end; ++i) {\n                merged[i] = incoming[i - start];\n            }\n            return merged;\n        },\n    };\n}\nexport function relayStylePagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        read: function (existing, _a) {\n            var canRead = _a.canRead;\n            if (!existing)\n                return;\n            var edges = existing.edges.filter(function (edge) { return canRead(edge.node); });\n            return __assign(__assign({}, existing), { edges: edges, pageInfo: __assign(__assign({}, existing.pageInfo), { startCursor: cursorFromEdge(edges, 0), endCursor: cursorFromEdge(edges, -1) }) });\n        },\n        merge: function (existing, incoming, _a) {\n            if (existing === void 0) { existing = makeEmptyData(); }\n            var args = _a.args;\n            if (!args)\n                return existing;\n            var incomingEdges = incoming.edges.slice(0);\n            if (incoming.pageInfo) {\n                updateCursor(incomingEdges, 0, incoming.pageInfo.startCursor);\n                updateCursor(incomingEdges, -1, incoming.pageInfo.endCursor);\n            }\n            var prefix = existing.edges;\n            var suffix = [];\n            if (args.after) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.after; });\n                if (index >= 0) {\n                    prefix = prefix.slice(0, index + 1);\n                }\n            }\n            else if (args.before) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.before; });\n                suffix = index < 0 ? prefix : prefix.slice(index);\n                prefix = [];\n            }\n            else {\n                prefix = [];\n            }\n            var edges = __spreadArrays(prefix, incomingEdges, suffix);\n            var pageInfo = __assign(__assign(__assign({}, incoming.pageInfo), existing.pageInfo), { startCursor: cursorFromEdge(edges, 0), endCursor: cursorFromEdge(edges, -1) });\n            var updatePageInfo = function (name) {\n                var value = incoming.pageInfo[name];\n                if (value !== void 0) {\n                    pageInfo[name] = value;\n                }\n            };\n            if (!prefix.length)\n                updatePageInfo(\"hasPreviousPage\");\n            if (!suffix.length)\n                updatePageInfo(\"hasNextPage\");\n            return __assign(__assign(__assign({}, existing), incoming), { edges: edges,\n                pageInfo: pageInfo });\n        },\n    };\n}\nfunction makeEmptyData() {\n    return {\n        edges: [],\n        pageInfo: {\n            hasPreviousPage: false,\n            hasNextPage: true,\n            startCursor: \"\",\n            endCursor: \"\",\n        },\n    };\n}\nfunction cursorFromEdge(edges, index) {\n    if (index < 0)\n        index += edges.length;\n    var edge = edges[index];\n    return edge && edge.cursor || \"\";\n}\nfunction updateCursor(edges, index, cursor) {\n    if (index < 0)\n        index += edges.length;\n    var edge = edges[index];\n    if (cursor && cursor !== edge.cursor) {\n        edges[index] = __assign(__assign({}, edge), { cursor: cursor });\n    }\n}\n//# sourceMappingURL=pagination.js.map"]},"metadata":{},"sourceType":"module"}